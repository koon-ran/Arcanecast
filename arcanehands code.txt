let's go through some key files from the working arcium dapp i found arcanehands and see if we can find something that can help use out

- arcium-client.ts

import { PublicKey, Connection, Keypair, Transaction, TransactionInstruction, SystemProgram } from '@solana/web3.js';
import * as anchor from '@project-serum/anchor';
import { Program, Idl, BN } from '@project-serum/anchor';
import {
  getCompDefAccOffset,
  getArciumAccountBaseSeed,
  getArciumProgAddress,
  RescueCipher,
  getMXEAccAddress,
  getMempoolAccAddress,
  getCompDefAccAddress,
  getExecutingPoolAccAddress,
  x25519,
  getComputationAccAddress,
  awaitComputationFinalization,
  getClusterAccAddress,
  getMXEPublicKey
} from '@arcium-hq/client';

export const ARCIUM_PROGRAM_ID = new PublicKey('3AqocbMpZD5sMhYun1wK31Y7cwR6EyhACwTVwFRuzWVY');

export const GAME_PROGRAM_ID = new PublicKey('3AqocbMpZD5sMhYun1wK31Y7cwR6EyhACwTVwFRuzWVY');

export const ARCIUM_MAIN_PROGRAM_ID = new PublicKey('BKck65TgoKRokMjQM3datB9oRwJ8rAj2jxPXvHXUvcL6');

// Use constants from @arcium-hq/client instead of hardcoded addresses

export const CLUSTER_OFFSET = 1078779259;

// MXE public key is now fetched dynamically using getMXEPublicKey

function randomBytes(size: number): Uint8Array {
  const bytes = new Uint8Array(size);
  if (typeof window !== 'undefined' && window.crypto && window.crypto.getRandomValues) {
    window.crypto.getRandomValues(bytes);
  } else {
    for (let i = 0; i < size; i++) {
      bytes[i] = Math.floor(Math.random() * 256);
    }
  }
  return bytes;
}

export enum Move {
  Rock = 0,
  Paper = 1,
  Scissors = 2
}

export enum GameResult {
  Player1Wins = 0,
  Player2Wins = 1,
  Draw = 2
}

export class ArciumClient {
  private connection: Connection;
  private wallet: anchor.Wallet;
  private provider: anchor.AnchorProvider;
  private lastTransactionSignature: string | null = null;
  private lastComputationOffset: BN | null = null;
  private programId: PublicKey;

  constructor(connection: Connection, wallet: anchor.Wallet, programId?: PublicKey) {
    this.connection = connection;
    this.wallet = wallet;
    this.programId = programId || GAME_PROGRAM_ID;
    
    this.provider = new anchor.AnchorProvider(
      connection,
      wallet,
      { commitment: 'confirmed' }
    );
  }

  async getMXEPublicKeyWithRetry(
    maxRetries: number = 10,
    retryDelayMs: number = 500
  ): Promise<Uint8Array> {
    for (let attempt = 1; attempt <= maxRetries; attempt++) {
      try {
        const mxePublicKey = await getMXEPublicKey(this.provider, this.programId);
        if (mxePublicKey) {
          return mxePublicKey;
        }
      } catch (error) {
        console.log(`Attempt ${attempt} failed to fetch MXE public key:`, error);
      }

      if (attempt < maxRetries) {
        console.log(
          `Retrying in ${retryDelayMs}ms... (attempt ${attempt}/${maxRetries})`
        );
        await new Promise((resolve) => setTimeout(resolve, retryDelayMs));
      }
    }

    throw new Error(
      `Failed to fetch MXE public key after ${maxRetries} attempts`
    );
  }

  async encryptAndSubmitMove(move: Move): Promise<string> {
    try {
      const privateKey = x25519.utils.randomPrivateKey();
      const publicKey = x25519.getPublicKey(privateKey);
      
      const mxePublicKey = await this.getMXEPublicKeyWithRetry();
      const sharedSecret = x25519.getSharedSecret(privateKey, mxePublicKey);
      const cipher = new RescueCipher(sharedSecret);
      
      const playerMove = BigInt(move);
      const plaintext = [playerMove];
      const nonce = randomBytes(16);
      const ciphertext = cipher.encrypt(plaintext, nonce);
      
      const offsetBytes = randomBytes(8);
      const hexString = Array.from(offsetBytes)
        .map(b => b.toString(16).padStart(2, '0'))
        .join('');
      const computationOffset = new BN(hexString, 16);
      this.lastComputationOffset = computationOffset;
      
      const [gameResultPda, gameResultBump] = PublicKey.findProgramAddressSync(
        [Buffer.from("game_result"), this.wallet.publicKey.toBuffer()],
        this.programId
      );
      
      const discriminator = Buffer.from([6, 203, 80, 37, 69, 14, 176, 11]);
      
      const data = Buffer.concat([
        discriminator,
        computationOffset.toArrayLike(Buffer, 'le', 8),
        Buffer.from(ciphertext[0]),
        Buffer.from(publicKey),
        Buffer.from(nonce).subarray(0, 16)
      ]);
      
      const mxeAccount = getMXEAccAddress(this.programId);
      const mempoolAccount = getMempoolAccAddress(this.programId);
      const executingPool = getExecutingPoolAccAddress(this.programId);
      const computationAccount = getComputationAccAddress(this.programId, computationOffset);
      const compDefAccount = getCompDefAccAddress(
        this.programId,
        Buffer.from(getCompDefAccOffset("play_rps")).readUInt32LE()
      );
      
      const clusterAccount = getClusterAccAddress(CLUSTER_OFFSET);
      // Use hardcoded addresses that match ARCIUM_FEE_POOL_ACCOUNT_ADDRESS and ARCIUM_CLOCK_ACCOUNT_ADDRESS from Rust
      const feePoolAccount = new PublicKey("7MGSS4iKNM4sVib7bDZDJhVqB6EcchPwVnTKenCY1jt3");
      const clockAccount = new PublicKey("FHriyvoZotYiFnbUzKFjzRSb2NiaC8RPWY7jtKuKhg65");

      // Get sign PDA account - seeds: ["SignerAccount"]
      const signPdaAccount = PublicKey.findProgramAddressSync(
        [Buffer.from("SignerAccount")],
        this.programId
      )[0];

      const initGameResultDiscriminator = Buffer.from([193, 15, 187, 77, 198, 11, 240, 89]);
      const initGameResultData = Buffer.concat([initGameResultDiscriminator]);

      const initGameResultIx = new TransactionInstruction({
        keys: [
          { pubkey: this.wallet.publicKey, isSigner: true, isWritable: true },
          { pubkey: gameResultPda, isSigner: false, isWritable: true },
          { pubkey: SystemProgram.programId, isSigner: false, isWritable: false },
        ],
        programId: this.programId,
        data: initGameResultData
      });

      const keys = [
        { pubkey: this.wallet.publicKey, isSigner: true, isWritable: true },
        { pubkey: signPdaAccount, isSigner: false, isWritable: true },
        { pubkey: mxeAccount, isSigner: false, isWritable: true },
        { pubkey: mempoolAccount, isSigner: false, isWritable: true },
        { pubkey: executingPool, isSigner: false, isWritable: true },
        { pubkey: computationAccount, isSigner: false, isWritable: true },
        { pubkey: compDefAccount, isSigner: false, isWritable: false },
        { pubkey: clusterAccount, isSigner: false, isWritable: true },
        { pubkey: feePoolAccount, isSigner: false, isWritable: true },
        { pubkey: clockAccount, isSigner: false, isWritable: false },
        { pubkey: SystemProgram.programId, isSigner: false, isWritable: false },
        { pubkey: ARCIUM_MAIN_PROGRAM_ID, isSigner: false, isWritable: false }
      ];
      
      const playRpsIx = new TransactionInstruction({
        keys,
        programId: this.programId,
        data
      });
      
      const transaction = new Transaction();
      
      try {
        await this.connection.getAccountInfo(gameResultPda);
      } catch (error) {
        transaction.add(initGameResultIx);
      }
      
      transaction.add(playRpsIx);
        
      const { blockhash } = await this.connection.getLatestBlockhash();
      transaction.recentBlockhash = blockhash;
      transaction.feePayer = this.wallet.publicKey;
        
      const signedTx = await this.wallet.signTransaction(transaction);
      const signature = await this.connection.sendRawTransaction(signedTx.serialize());
      
      await this.connection.confirmTransaction(signature, 'confirmed');
      
      this.lastTransactionSignature = signature;
      
      this.lastComputationOffset = computationOffset;
      
      try {
        const timeoutPromise = new Promise((_, reject) => 
          setTimeout(() => reject(new Error('Finalization timeout')), 3000)
        );
        
        const finalizationPromise = awaitComputationFinalization(
          this.provider,
          computationOffset,
          this.programId,
          'confirmed'
        );
        
        const finalizeSig = await Promise.race([
          timeoutPromise,
          finalizationPromise
        ]) as string;
        
        return signature;
      } catch (error) {
        return signature;
      }
    } catch (error) {
      console.error("Error in encryptAndSubmitMove:", error);
      throw error;
    }
  }

  async getGameResult(playerMove: Move): Promise<{
    computerMove: Move,
    result: GameResult,
    resultHash: string
  }> {
    try {
      if (this.lastTransactionSignature) {
        try {
          const txInfo = await this.connection.getTransaction(this.lastTransactionSignature, {
            maxSupportedTransactionVersion: 0
          });
          
          if (txInfo?.meta?.logMessages) {
            for (const log of txInfo.meta.logMessages) {
              if (log.includes("Program log: Result:")) {
                const resultText = log.split("Result: ")[1];
                
                if (resultText.includes("Player wins")) {
                  const computerMove = playerMove === Move.Rock ? Move.Scissors :
                                     playerMove === Move.Paper ? Move.Rock : Move.Paper;
                  return {
                    computerMove,
                    result: GameResult.Player1Wins,
                    resultHash: this.lastTransactionSignature
                  };
                } else if (resultText.includes("House wins")) {
                  const computerMove = playerMove === Move.Rock ? Move.Paper :
                                     playerMove === Move.Paper ? Move.Scissors : Move.Rock;
                  return {
                    computerMove,
                    result: GameResult.Player2Wins,
                    resultHash: this.lastTransactionSignature
                  };
                } else if (resultText.includes("Tie")) {
                  return {
                    computerMove: playerMove,
                    result: GameResult.Draw,
                    resultHash: this.lastTransactionSignature
                  };
                }
              }
            }
          }
        } catch (logError) {
          console.warn("Could not fetch transaction logs:", logError);
        }
      }
      
    const computerMove = Math.floor(Math.random() * 3) as Move;
    
    let result: GameResult;
    if (playerMove === computerMove) {
      result = GameResult.Draw;
    } else if (
      (playerMove === Move.Rock && computerMove === Move.Scissors) ||
      (playerMove === Move.Paper && computerMove === Move.Rock) ||
      (playerMove === Move.Scissors && computerMove === Move.Paper)
    ) {
      result = GameResult.Player1Wins;
    } else {
      result = GameResult.Player2Wins;
    }
    
    return {
      computerMove,
      result,
        resultHash: this.lastTransactionSignature || `fallback_${Date.now()}`
      };
    } catch (error) {
      console.error("Error getting game result:", error);
      throw error;
    }
  }

  async initializeCompDef(): Promise<string> {
    return "already_initialized";
  }

  getLastTransactionSignature(): string | null {
    return this.lastTransactionSignature;
  }
} 

- poll-client.ts

import { Connection, PublicKey, Transaction, SystemProgram, TransactionInstruction, ComputeBudgetProgram } from '@solana/web3.js';
import { Buffer } from 'buffer';
import * as anchor from '@coral-xyz/anchor';
import {
  awaitComputationFinalization,
  getCompDefAccOffset,
  getMXEAccAddress,
  getMempoolAccAddress,
  getCompDefAccAddress,
  getExecutingPoolAccAddress,
  getComputationAccAddress,
  getClusterAccAddress,
  deserializeLE
} from '@arcium-hq/client';

export const ARCIUM_MAIN_PROGRAM_ID = new PublicKey("BKck65TgoKRokMjQM3datB9oRwJ8rAj2jxPXvHXUvcL6");
// Use constants from @arcium-hq/client instead of hardcoded addresses

const CLUSTER_OFFSET = 1078779259;

function randomBytes(size: number): Uint8Array {
  const bytes = new Uint8Array(size);
  if (typeof window !== 'undefined' && window.crypto?.getRandomValues) {
    window.crypto.getRandomValues(bytes);
  } else {
    for (let i = 0; i < size; i++) bytes[i] = Math.floor(Math.random() * 256);
  }
  return bytes;
}

export class PollClient {
  private connection: Connection;
  private wallet: anchor.Wallet;
  private provider: anchor.AnchorProvider;
  private programId: PublicKey;
  private lastTransactionSignature: string | null = null;
  private lastComputationOffset: anchor.BN | null = null;

  constructor(connection: Connection, wallet: anchor.Wallet, programId: PublicKey) {
    this.connection = connection;
    this.wallet = wallet;
    this.programId = programId;
    this.provider = new anchor.AnchorProvider(connection, wallet, { commitment: 'confirmed' });
  }

  async initializeVoteSystem(): Promise<boolean> {
    try {
      // First ensure MXE is initialized
      await this.ensureMXEInitialized();

      // Then check and initialize computation definitions
      await this.ensureComputationDefinitionsInitialized();

      return true;
    } catch (error) {
      console.error("Error initializing vote system:", error);
      return false;
    }
  }

  async ensureMXEInitialized(): Promise<void> {
    const mxeAccount = getMXEAccAddress(this.programId);
    try {
      const accountInfo = await this.connection.getAccountInfo(mxeAccount);
      if (!accountInfo) {
        await this.initMXEAccount();
      } else {
        
      }
    } catch (error) {
      await this.initMXEAccount();
    }
  }

  async initMXEAccount(): Promise<void> {
    const initMXEDiscriminator = Buffer.from([240, 227, 11, 166, 193, 167, 25, 79]);
    const mxeAccount = getMXEAccAddress(this.programId);

    const keys = [
      { pubkey: this.wallet.publicKey, isSigner: true, isWritable: true },
      { pubkey: mxeAccount, isSigner: false, isWritable: true },
      { pubkey: ARCIUM_MAIN_PROGRAM_ID, isSigner: false, isWritable: false },
      { pubkey: SystemProgram.programId, isSigner: false, isWritable: false },
    ];

    const transaction = new Transaction();
    const initMXEIx = new TransactionInstruction({
      keys,
      programId: ARCIUM_MAIN_PROGRAM_ID,
      data: initMXEDiscriminator
    });
    transaction.add(initMXEIx);

    const modifyComputeUnits = ComputeBudgetProgram.setComputeUnitLimit({
      units: 200000
    });
    transaction.add(modifyComputeUnits);

    const addPriorityFee = ComputeBudgetProgram.setComputeUnitPrice({
      microLamports: 1_000_000
    });
    transaction.add(addPriorityFee);

    const { blockhash, lastValidBlockHeight } = await this.connection.getLatestBlockhash('confirmed');
    transaction.recentBlockhash = blockhash;
    transaction.lastValidBlockHeight = lastValidBlockHeight;
    transaction.feePayer = this.wallet.publicKey;

    const signedTx = await this.wallet.signTransaction(transaction);
    const signature = await this.connection.sendRawTransaction(signedTx.serialize(), {
      skipPreflight: true,
      preflightCommitment: 'confirmed'
    });

    console.log("MXE init transaction:", signature);
    await this.connection.confirmTransaction({
      signature,
      blockhash,
      lastValidBlockHeight
    }, 'confirmed');

    console.log("MXE account initialized successfully");
  }

  async ensureComputationDefinitionsInitialized(): Promise<void> {
    const compDefs = ['init_vote_stats', 'vote', 'reveal_result'];

    for (const compDef of compDefs) {
      const compDefOffset = Buffer.from(getCompDefAccOffset(compDef)).readUInt32LE();
      const compDefAddress = getCompDefAccAddress(this.programId, compDefOffset);

      try {
        await this.connection.getAccountInfo(compDefAddress);
      } catch (error) {
        await this.initComputationDefinition(compDef);
      }
    }
  }

  async initComputationDefinition(compDefName: string): Promise<void> {
    const compDefOffset = Buffer.from(getCompDefAccOffset(compDefName)).readUInt32LE();
    const compDefAddress = getCompDefAccAddress(this.programId, compDefOffset);
    const mxeAccount = getMXEAccAddress(this.programId);

    // Discriminator for init_computation_definition
    const initCompDefDiscriminator = Buffer.from([117, 167, 172, 48, 88, 134, 95, 91]);

    const keys = [
      { pubkey: this.wallet.publicKey, isSigner: true, isWritable: true },
      { pubkey: mxeAccount, isSigner: false, isWritable: true },
      { pubkey: compDefAddress, isSigner: false, isWritable: true },
      { pubkey: ARCIUM_MAIN_PROGRAM_ID, isSigner: false, isWritable: false },
      { pubkey: SystemProgram.programId, isSigner: false, isWritable: false },
    ];

    const transaction = new Transaction();
    const initCompDefIx = new TransactionInstruction({
      keys,
      programId: ARCIUM_MAIN_PROGRAM_ID,
      data: initCompDefDiscriminator
    });
    transaction.add(initCompDefIx);

    const modifyComputeUnits = ComputeBudgetProgram.setComputeUnitLimit({
      units: 200000
    });
    transaction.add(modifyComputeUnits);

    const addPriorityFee = ComputeBudgetProgram.setComputeUnitPrice({
      microLamports: 1_000_000
    });
    transaction.add(addPriorityFee);

    const { blockhash, lastValidBlockHeight } = await this.connection.getLatestBlockhash('confirmed');
    transaction.recentBlockhash = blockhash;
    transaction.lastValidBlockHeight = lastValidBlockHeight;
    transaction.feePayer = this.wallet.publicKey;

    const signedTx = await this.wallet.signTransaction(transaction);
    const signature = await this.connection.sendRawTransaction(signedTx.serialize(), {
      skipPreflight: true,
      preflightCommitment: 'confirmed'
    });

    console.log(`${compDefName} init transaction:`, signature);
    await this.connection.confirmTransaction({
      signature,
      blockhash,
      lastValidBlockHeight
    }, 'confirmed');

    console.log(`${compDefName} computation definition initialized successfully`);
  }

  async pollAccountExists(pollId: number): Promise<boolean> {
    try {
      const [pollPda] = anchor.web3.PublicKey.findProgramAddressSync(
        [
          Buffer.from("poll"), 
          this.wallet.publicKey.toBuffer(), 
          Buffer.from(new Uint32Array([pollId]).buffer)
        ],
        this.programId
      );
      
      const account = await this.connection.getAccountInfo(pollPda);
      return account !== null;
    } catch (error) {
      console.error("Error checking poll account:", error);
      return false;
    }
  }

  async findAvailablePollId(): Promise<number> {
    let candidateId = Math.floor(Math.random() * 1000000);
    
    for (let i = 0; i < 10; i++) {
      const exists = await this.pollAccountExists(candidateId);
      if (!exists) {
        return candidateId;
      }
      candidateId = Math.floor(Math.random() * 1000000);
    }
    
    return Math.floor(Math.random() * 1000000000) + 1000000;
  }

  async createNewPoll(pollId: number, question: string): Promise<string> {
    const exists = await this.pollAccountExists(pollId);
    if (exists) {
      pollId = await this.findAvailablePollId();
    }
    
    try {
      const offsetBytes = randomBytes(8);
      const computationOffset = new anchor.BN(offsetBytes, undefined, 'le');
      this.lastComputationOffset = computationOffset;
      
      const nonce = randomBytes(16);
      const nonceBN = new anchor.BN(deserializeLE(nonce).toString());
      
      const [pollPda] = anchor.web3.PublicKey.findProgramAddressSync(
        [
          Buffer.from("poll"), 
          this.wallet.publicKey.toBuffer(), 
          Buffer.from(new Uint32Array([pollId]).buffer)
        ],
        this.programId
      );
      
      const mxeAccount = getMXEAccAddress(this.programId);
      const mempoolAccount = getMempoolAccAddress(this.programId);
      const executingPool = getExecutingPoolAccAddress(this.programId);
      const computationAccount = getComputationAccAddress(this.programId, computationOffset);
      const compDefAccount = getCompDefAccAddress(
        this.programId,
        Buffer.from(getCompDefAccOffset('init_vote_stats')).readUInt32LE()
      );
      const clusterAccount = getClusterAccAddress(CLUSTER_OFFSET);
      // Use dynamic addresses from Arcium client for v0.3.0 compatibility
      const feePoolAccount = new PublicKey("7MGSS4iKNM4sVib7bDZDJhVqB6EcchPwVnTKenCY1jt3"); // Devnet fee pool
      const clockAccount = new PublicKey("FHriyvoZotYiFnbUzKFjzRSb2NiaC8RPWY7jtKuKhg65");

      // Get sign PDA account - seeds: ["SignerAccount"]
      const signPdaAccount = PublicKey.findProgramAddressSync(
        [Buffer.from("SignerAccount")],
        this.programId
      )[0];

      const createNewPollDiscriminator = Buffer.from([18, 23, 205, 123, 193, 24, 162, 162]);
      
      const data = Buffer.concat([
        createNewPollDiscriminator,
        computationOffset.toArrayLike(Buffer, 'le', 8),
        (() => {
          const idBuffer = Buffer.alloc(4);
          idBuffer.writeUInt32LE(pollId, 0);
          return idBuffer;
        })(),
        (() => {
          const strBytes = Buffer.from(question);
          const lenBuf = Buffer.alloc(4);
          lenBuf.writeUInt32LE(strBytes.length, 0);
          return Buffer.concat([lenBuf, strBytes]);
        })(),
        nonceBN.toArrayLike(Buffer, 'le', 16)
      ]);

      const keys = [
        { pubkey: this.wallet.publicKey, isSigner: true, isWritable: true },
        { pubkey: signPdaAccount, isSigner: false, isWritable: true },
        { pubkey: mxeAccount, isSigner: false, isWritable: true },
        { pubkey: mempoolAccount, isSigner: false, isWritable: true },
        { pubkey: executingPool, isSigner: false, isWritable: true },
        { pubkey: computationAccount, isSigner: false, isWritable: true },
        { pubkey: compDefAccount, isSigner: false, isWritable: false },
        { pubkey: clusterAccount, isSigner: false, isWritable: true },
        { pubkey: feePoolAccount, isSigner: false, isWritable: true },
        { pubkey: clockAccount, isSigner: false, isWritable: false },
        { pubkey: SystemProgram.programId, isSigner: false, isWritable: false },
        { pubkey: ARCIUM_MAIN_PROGRAM_ID, isSigner: false, isWritable: false },
        { pubkey: pollPda, isSigner: false, isWritable: true },
      ];

      const transaction = new Transaction();
      
      const createPollIx = new TransactionInstruction({
        keys,
        programId: this.programId,
        data
      });
      transaction.add(createPollIx);
      
      const modifyComputeUnits = ComputeBudgetProgram.setComputeUnitLimit({ 
        units: 200000
      });
      transaction.add(modifyComputeUnits);

      const addPriorityFee = ComputeBudgetProgram.setComputeUnitPrice({
        microLamports: 1_000_000
      });
      transaction.add(addPriorityFee);
      
      const { blockhash, lastValidBlockHeight } = await this.connection.getLatestBlockhash('confirmed');
      transaction.recentBlockhash = blockhash;
      transaction.lastValidBlockHeight = lastValidBlockHeight;
      transaction.feePayer = this.wallet.publicKey;
      
      const signedTx = await this.wallet.signTransaction(transaction);
      
      const signature = await this.connection.sendRawTransaction(signedTx.serialize(), {
        skipPreflight: true,
        preflightCommitment: 'confirmed'
      });
      
      this.lastTransactionSignature = signature;
      
      await this.connection.confirmTransaction({
        signature,
        blockhash,
        lastValidBlockHeight
      }, 'confirmed');
      
      return signature;
    } catch (error) {
      console.error('Error creating poll:', error);
      throw error;
    }
  }

  getLastTransactionSignature(): string | null {
    return this.lastTransactionSignature;
  }
} 

- game-client.ts

import * as anchor from '@project-serum/anchor';
import { Program, Idl } from '@project-serum/anchor';
import { PublicKey, SystemProgram } from '@solana/web3.js';
import { ArciumClient, Move as ArciumMove, GameResult as ArciumGameResult, ARCIUM_PROGRAM_ID } from './arcium-client';

export { ARCIUM_PROGRAM_ID } from './arcium-client';

const API_URL = '/api';

let lastWorkerResponse = null;
let lastWorkerError = null;

export class GameClient {
    provider: anchor.AnchorProvider;
    arciumClient: ArciumClient;
    transactionInProgress: boolean = false;
    worker: Worker | null = null;

    constructor(provider: anchor.AnchorProvider, programId: PublicKey) {
        this.provider = provider;
        this.arciumClient = new ArciumClient(provider.connection, provider.wallet);
    }

    async initialize() {
        const gameState = anchor.web3.Keypair.generate();
        return gameState;
    }

    async submitMove(gameState: PublicKey, choice: number) {
        try {
            this.transactionInProgress = true;
            
            try {
                const tx = await this.arciumClient.encryptAndSubmitMove(choice as ArciumMove);
                
                const isErrorTx = tx.includes('error') || tx.includes('fallback');
                
                const confidentialResult = await this.arciumClient.getGameResult(choice as ArciumMove);
                
                this.transactionInProgress = false;
                
                return {
                    tx, 
                    player: this.provider.wallet.publicKey,
                    result: {
                        tx,
                        confidentialResult
                    }
                };
            } catch (error) {
                this.transactionInProgress = false;
                console.error("Error processing move:", error);

                // ????????? ?? ?????? ?????????? ???????
                const errorMessage = error.message || String(error);
                if (errorMessage.includes("debit an account") ||
                    errorMessage.includes("no record of a prior credit")) {
                    throw new Error("Insufficient SOL balance. Please get some test SOL from the faucet.");
                }

                if (error.message && (
                    error.message.includes("User rejected") ||
                    error.message.includes("cancelled") ||
                    error.message.includes("rejected") ||
                    error.message.includes("denied") ||
                    error.message.includes("decline") ||
                    error.message.includes("cancel")
                )) {
                    throw new Error("Transaction was rejected by the wallet");
                }
                
                const computerChoice = Math.floor(Math.random() * 3) as ArciumMove;
                let result: ArciumGameResult;
                
                if (choice === computerChoice) {
                    result = ArciumGameResult.Draw;
                } else if (
                    (choice === ArciumMove.Rock && computerChoice === ArciumMove.Scissors) ||
                    (choice === ArciumMove.Paper && computerChoice === ArciumMove.Rock) ||
                    (choice === ArciumMove.Scissors && computerChoice === ArciumMove.Paper)
                ) {
                    result = ArciumGameResult.Player1Wins;
                } else {
                    result = ArciumGameResult.Player2Wins;
                }
                
                const mockTx = `fallback_tx_${Date.now()}_${Array.from({length: 16}, () => 
                    Math.floor(Math.random() * 16).toString(16)).join('')}`;
                
                return {
                    tx: mockTx,
                    player: this.provider.wallet.publicKey,
                    result: {
                        tx: mockTx,
                        confidentialResult: {
                            computerMove: computerChoice,
                            result: result,
                            resultHash: "fallback_hash_" + Date.now()
                        }
                    }
                };
            }
        } catch (err) {
            this.transactionInProgress = false;
            console.error("Error submitting move:", err);
            throw err;
        }
    }

    isTransactionInProgress() {
        return this.transactionInProgress;
    }
} 

- GameComponent.tsx

import React, { useState, useEffect, useRef } from 'react';
import { useAnchorWallet, useWallet } from '@solana/wallet-adapter-react';
import { WalletMultiButton } from '@solana/wallet-adapter-react-ui';
import { Connection, PublicKey } from '@solana/web3.js';
import { AnchorProvider } from '@project-serum/anchor';
import { GameClient, ARCIUM_PROGRAM_ID } from './game-client';
import * as anchor from '@project-serum/anchor';
import { Component as LetterGlitch } from '../client/src/components/ui/letter-glitch';
import { FaucetButton } from './components/FaucetButton';
import { UserMenuDropdown } from '../components/UserMenuDropdown';
import { VotingModal } from './components/VotingModal';
import { DecryptedThrone } from './components/DecryptedThrone';
import { LobbyModal } from './components/LobbyModal';

const PROGRAM_ID = ARCIUM_PROGRAM_ID;

const AnimatedLockIcon = ({ isAnimated, ...props }: React.SVGProps<SVGSVGElement> & { isAnimated?: boolean }) => (
  <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" {...props}>
    <rect 
      x="3" y="11" width="18" height="11" rx="2" ry="2"
      style={{
        transform: isAnimated ? 'scale(1.1)' : 'scale(1)',
        transformOrigin: 'center',
        transition: 'transform 0.3s ease-out'
      }}
    />
    <path 
      d="M7 11V7a5 5 0 0 1 10 0v4"
      style={{
        transform: isAnimated ? 'translateY(-1.5px)' : 'translateY(0)',
        transition: 'transform 0.3s ease-out'
      }}
    />
  </svg>
);

const LockIcon = (props: React.SVGProps<SVGSVGElement>) => (
  <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" {...props}>
    <rect x="3" y="11" width="18" height="11" rx="2" ry="2"></rect>
    <path d="M7 11V7a5 5 0 0 1 10 0v4"></path>
  </svg>
);

const ShieldIcon = (props: React.SVGProps<SVGSVGElement>) => (
  <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" {...props}>
    <path d="M12 22s8-4 8-10V5l-8-3-8 3v7c0 6 8 10 8 10z"></path>
  </svg>
);

const ChipIcon = (props: React.SVGProps<SVGSVGElement>) => (
  <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" {...props}>
    <rect x="4" y="4" width="16" height="16" rx="2"></rect>
    <rect x="9" y="9" width="6" height="6"></rect>
    <path d="M9 2v2"></path>
    <path d="M15 2v2"></path>
    <path d="M9 20v2"></path>
    <path d="M15 20v2"></path>
    <path d="M2 9h2"></path>
    <path d="M2 15h2"></path>
    <path d="M20 9h2"></path>
    <path d="M20 15h2"></path>
  </svg>
);

const AnimatedTrophyIconMain = ({ isAnimated, ...props }: React.SVGProps<SVGSVGElement> & { isAnimated?: boolean }) => (
  <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" {...props}>
    <path d="M6 9H4.5a2.5 2.5 0 0 1 0-5H6"></path>
    <path d="M18 9h1.5a2.5 2.5 0 0 0 0-5H18"></path>
    <path 
      d="M4 22h16"
      style={{
        transform: isAnimated ? 'scaleX(1.5)' : 'scaleX(1)',
        transformOrigin: 'center',
        transition: 'transform 0.3s ease-out'
      }}
    />
    <path 
      d="M10 14.66V17c0 .55-.47.98-.97 1.21C7.85 18.75 7 20.24 7 22"
      style={{
        transform: isAnimated ? 'translateY(-2px)' : 'translateY(0)',
        transition: 'transform 0.3s ease-out'
      }}
    />
    <path 
      d="M14 14.66V17c0 .55.47.98.97 1.21C16.15 18.75 17 20.24 17 22"
      style={{
        transform: isAnimated ? 'translateY(-2px)' : 'translateY(0)',
        transition: 'transform 0.3s ease-out'
      }}
    />
    <path 
      d="M9 2v7.5"
      style={{
        transform: isAnimated ? 'translateY(-2px)' : 'translateY(0)',
        transition: 'transform 0.3s ease-out'
      }}
    />
    <path 
      d="M15 2v7.5"
      style={{
        transform: isAnimated ? 'translateY(-2px)' : 'translateY(0)',
        transition: 'transform 0.3s ease-out'
      }}
    />
    <path 
      d="M12 2v10l-3-2"
      style={{
        transform: isAnimated ? 'translateY(-2px)' : 'translateY(0)',
        transition: 'transform 0.3s ease-out'
      }}
    />
    <path 
      d="M12 12l3-2"
      style={{
        transform: isAnimated ? 'translateY(-2px)' : 'translateY(0)',
        transition: 'transform 0.3s ease-out'
      }}
    />
  </svg>
);

const AnimatedClockIcon = ({ isAnimated, ...props }: React.SVGProps<SVGSVGElement> & { isAnimated?: boolean }) => (
    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" {...props}>
        <circle cx="12" cy="12" r="10"></circle>
        {/* ??????? ??????? (????????, ?????????) - ?????????? ?? 2 ???? */}
        <line 
            x1="12" y1="12" x2="16" y2="16"
            strokeWidth="3"
            style={{
                transform: isAnimated ? 'rotate(360deg)' : 'rotate(0deg)',
                transformOrigin: '12px 12px',
                transition: 'transform 1s ease-in-out'
            }}
        />
        {/* ???????? ??????? (???????, ???????) - ?????????? ?? 12 ????? */}
        <line 
            x1="12" y1="12" x2="12" y2="6"
            strokeWidth="2"
            style={{
                transform: isAnimated ? 'rotate(720deg)' : 'rotate(0deg)',
                transformOrigin: '12px 12px',
                transition: 'transform 0.8s ease-in-out'
            }}
        />
        {/* ??????????? ????? */}
        <circle cx="12" cy="12" r="1.5" fill="currentColor" />
    </svg>
);

const ClockIcon = (props: React.SVGProps<SVGSVGElement>) => (
  <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" {...props}>
    <circle cx="12" cy="12" r="10"></circle>
    <polyline points="12 6 12 12 16 14"></polyline>
  </svg>
);

const AnimatedBookIcon = ({ isAnimated, ...props }: React.SVGProps<SVGSVGElement> & { isAnimated?: boolean }) => (
  <svg 
    xmlns="http://www.w3.org/2000/svg" 
    width="24" 
    height="24" 
    viewBox="0 0 24 24" 
    fill="none" 
    stroke="currentColor" 
    strokeWidth="2" 
    strokeLinecap="round" 
    strokeLinejoin="round" 
    {...props}
    style={{
      transform: isAnimated ? 'rotateY(20deg) scale(1.2)' : 'rotateY(0) scale(1)',
      transition: 'transform 0.3s ease-out',
      transformOrigin: 'center',
      ...props.style
    }}
  >
    <path 
      d="M12 6.253v13m0-13C10.832 5.477 9.246 5 7.5 5S4.168 5.477 3 6.253v13C4.168 18.477 5.754 18 7.5 18s3.332.477 4.5 1.253m0-13C13.168 5.477 14.754 5 16.5 5c1.746 0 3.332.477 4.5 1.253v13C19.832 18.477 18.246 18 16.5 18c-1.746 0-3.332.477-4.5 1.253"
      style={{
        transformOrigin: 'center',
        animation: isAnimated ? 'book-pages 0.6s ease-out' : 'none'
      }}
    />
  </svg>
);

const AnimatedTrophyIconGame = ({ isAnimated, ...props }: React.SVGProps<SVGSVGElement> & { isAnimated?: boolean }) => (
  <svg 
    xmlns="http://www.w3.org/2000/svg" 
    width="24" 
    height="24" 
    viewBox="0 0 24 24" 
    fill="none" 
    stroke="currentColor" 
    strokeWidth="2" 
    strokeLinecap="round" 
    strokeLinejoin="round" 
    {...props}
    style={{
      transform: isAnimated ? 'scale(1.2) rotate(5deg)' : 'scale(1) rotate(0deg)',
      transition: 'transform 0.3s ease-out',
      transformOrigin: 'center',
      ...props.style
    }}
  >
    <path d="M6 9H4.5a2.5 2.5 0 0 1 0-5H6"></path>
    <path d="M18 9h1.5a2.5 2.5 0 0 0 0-5H18"></path>
    <path 
      d="M4 22h16"
      style={{
        animation: isAnimated ? 'trophy-base 0.4s ease-out' : 'none'
      }}
    />
    <path 
      d="M10 14.66V17c0 .55-.47.98-.97 1.21C7.85 18.75 7 20.24 7 22"
      style={{
        animation: isAnimated ? 'trophy-shine 0.5s ease-out 0.1s' : 'none'
      }}
    />
    <path 
      d="M14 14.66V17c0 .55.47.98.97 1.21C16.15 18.75 17 20.24 17 22"
      style={{
        animation: isAnimated ? 'trophy-shine 0.5s ease-out 0.1s' : 'none'
      }}
    />
    <path 
      d="M18 2H6v7a6 6 0 0 0 12 0V2Z"
      style={{
        animation: isAnimated ? 'trophy-glow 0.6s ease-out' : 'none'
      }}
    />
  </svg>
);

export const GameComponent: React.FC = () => {
    const [choice, setChoice] = useState<number | null>(null);
    const [gameState, setGameState] = useState<PublicKey | null>(null);
    const [loading, setLoading] = useState(false);
    const [result, setResult] = useState<string | null>(null);
    const [txId, setTxId] = useState<string | null>(null);
    const [initializing, setInitializing] = useState(false);
    const [gameResult, setGameResult] = useState<'win' | 'lose' | 'draw' | null>(null);
    const [computerChoice, setComputerChoice] = useState<number | null>(null);
    const [showResult, setShowResult] = useState<boolean>(false);
    const [transactionCancelled, setTransactionCancelled] = useState<boolean>(false);
    const [transactionCompleted, setTransactionCompleted] = useState<boolean>(false);
    const [error, setError] = useState<string | null>(null);
    const [userRejectedTx, setUserRejectedTx] = useState<boolean>(false);
    const [isVotingModalOpen, setIsVotingModalOpen] = useState(false);
    const [showVotingResults, setShowVotingResults] = useState(false);
    const [isDropdownOpen, setIsDropdownOpen] = useState(false);
    const [isDecryptedThroneOpen, setIsDecryptedThroneOpen] = useState(false);
    const [showDecryptedThroneResults, setShowDecryptedThroneResults] = useState(false);
    const [isEventsButtonAnimated, setIsEventsButtonAnimated] = useState(false);
    const [isVotingButtonAnimated, setIsVotingButtonAnimated] = useState(false);
    const [isThroneButtonAnimated, setIsThroneButtonAnimated] = useState(false);
    const [isPracticeButtonAnimated, setIsPracticeButtonAnimated] = useState(false);
    const [isRankedButtonAnimated, setIsRankedButtonAnimated] = useState(false);
    const [isGlitching, setIsGlitching] = useState(false);
    const [glitchIntervalId, setGlitchIntervalId] = useState<NodeJS.Timeout | null>(null);
    const [gameMode, setGameMode] = useState<'practice' | 'ranked'>('practice');
    const [dailyLimit, setDailyLimit] = useState({
        attempts_used: 0,
        attempts_remaining: 5,
        limit_reached: false
    });
    const [timeUntilReset, setTimeUntilReset] = useState('');
    const [isLobbyModalOpen, setIsLobbyModalOpen] = useState(false);
    const [pendingVsComputerGame, setPendingVsComputerGame] = useState(false);
    const pendingVsComputerGameRef = useRef(false);
    const pendingChoiceRef = useRef<number | null>(null);
    const [waitingForOpponent, setWaitingForOpponent] = useState(false);
    const [myLobbyId, setMyLobbyId] = useState<string | null>(null);
    const [showLobbyMenu, setShowLobbyMenu] = useState(false);
    const [lobbyData, setLobbyData] = useState<any>(null);
    const [isPvPGame, setIsPvPGame] = useState(false);
    const pollingIntervalRef = useRef<NodeJS.Timeout | null>(null);
    const dropdownRef = useRef<HTMLDivElement>(null);
    
    const wallet = useAnchorWallet();
    const { connected, publicKey } = useWallet();

    // ?????????????? ????????? ????? ?? ??
    useEffect(() => {
        const checkActiveLobby = async () => {
            if (!publicKey) return;
            
            try {
                const response = await fetch(`/api/lobbies/my-lobby/${publicKey.toString()}`);
                const data = await response.json();
                
                if (data.lobby) {
                    setMyLobbyId(data.lobby.id);
                    setLobbyData(data.lobby);
                    localStorage.setItem('myLobbyId', data.lobby.id);
                    
                    // ???? ???????????? ??? ?????? ??? - ?????????? ????? ????
                    const userMadeChoice = data.lobby.is_creator ? 
                        data.lobby.creator_choice !== null : 
                        data.lobby.joiner_choice !== null;
                    
                    if (userMadeChoice) {
                        setChoice(data.lobby.is_creator ? data.lobby.creator_choice : data.lobby.joiner_choice);
                        setShowLobbyMenu(true);
                        setWaitingForOpponent(true);
                        setResult(null); // ??????? ????????? ??? ?????? ????? ????
                        localStorage.setItem('waitingForOpponent', 'true');

                        // ???????? ???????? ?????????? ?? ???? ??????? ??? ???????????? ??? ?????? ???
                        startPollGameResult(data.lobby.id);
                    } else {
                        // ???????????? ??? ?? ?????? ???
                        setResult('Please select your move (Rock, Paper, or Scissors) and wait for opponent');
                    }
                } else {
                    // ??????? ???? ????? ?? ??????? ? ??
                    localStorage.removeItem('myLobbyId');
                    localStorage.removeItem('waitingForOpponent');
                }
            } catch (error: any) {
                console.error('Error checking active lobby:', error);

                // ??????????? ????????? ?????? "Lobby not found"
                if (error.message && error.message.includes('Lobby not found')) {
                    // ??????? ????????? ????? ??? ?????? "Lobby not found"
                    setMyLobbyId(null);
                    setWaitingForOpponent(false);
                    setShowLobbyMenu(false);
                    setLobbyData(null);
                    setChoice(null);
                    localStorage.removeItem('myLobbyId');
                    localStorage.removeItem('waitingForOpponent');
                }
            }
        };
        
        checkActiveLobby();
    }, [publicKey]);

    // ??????? ??? ???????? ???????? ??????
    const fetchDailyLimit = async () => {
        if (!publicKey) return;
        
        try {
            const response = await fetch(`/api/daily-limit/${publicKey.toString()}`);
            if (response.ok) {
                const data = await response.json();
                setDailyLimit(data);
            }
        } catch (error) {

        }
    };

    // ???????? ???????? ?????? ??? ??????????? ????????
    useEffect(() => {
        if (connected && publicKey) {
            fetchDailyLimit();
            fetchServerTime(); // ?????????????? ????? ? ????????
        }
    }, [connected, publicKey]);

    // ????????? ??? ?????????? ??????? (?????? ?? ????????? ??????? ???????)
    const [serverTimeOffset, setServerTimeOffset] = useState<number>(0);

    // ??????? ??? ????????? ?????????? ???????
    const fetchServerTime = async () => {
        try {
            const response = await fetch('/api/server-time');
            if (response.ok) {
                const data = await response.json();
                const serverTime = new Date(data.server_time_utc).getTime();
                const clientTime = Date.now();
                setServerTimeOffset(serverTime - clientTime);
            }
        } catch (error) {

        }
    };

    // ??????? ??? ????????? ?????????? ??????? (?????????? ?? ????????? ??????? ???????)
    const getServerTime = () => {
        return new Date(Date.now() + serverTimeOffset);
    };

    // ??????? ??? ??????? ??????? ?? ?????? ?????? (?? ?????? ?????????? ???????)
    const calculateTimeUntilReset = () => {
        const now = getServerTime(); // ?????????? ????????? ?????!
        const tomorrow = new Date(now.getTime());
        // ????????????? ????????? ??????? ?? UTC
        tomorrow.setUTCDate(tomorrow.getUTCDate() + 1);
        tomorrow.setUTCHours(0, 0, 0, 0); // ??????? ?????????? ??? ?? UTC
        
        const diff = tomorrow.getTime() - now.getTime();
        const hours = Math.floor(diff / (1000 * 60 * 60));
        const minutes = Math.floor((diff % (1000 * 60 * 60)) / (1000 * 60));
        const seconds = Math.floor((diff % (1000 * 60)) / 1000);

        return `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
    };

    // ?????????? ??????? ? ???????? ?? ????? ?????? ? ??????? UTC
    useEffect(() => {
        let intervalId: NodeJS.Timeout;
        
        if (connected && publicKey) {
            intervalId = setInterval(() => {
                const newTime = calculateTimeUntilReset();
                
                // ????????? ?????? ?????? ???? ????? ?????????
                if (dailyLimit.limit_reached) {
                    setTimeUntilReset(newTime);
                }
                
                // ????????? ????? ?????? ? ??????? UTC ??? ???? ?????????????
                if (newTime === '00:00:00') {
                    setTimeout(async () => {
                        console.log('Midnight UTC reached, refreshing daily limit...');
                        await fetchDailyLimit();
                    }, 1000);
                }
            }, 1000);
            
            // ????????????? ????????? ???????? ???????, ???? ????? ?????????
            if (dailyLimit.limit_reached) {
                setTimeUntilReset(calculateTimeUntilReset());
            }
        }
        
        return () => {
            if (intervalId) {
                clearInterval(intervalId);
            }
        };
    }, [connected, publicKey, dailyLimit.limit_reached]);

    // Close dropdown when clicking outside
    useEffect(() => {
        const handleClickOutside = (event: MouseEvent) => {
            if (dropdownRef.current && !dropdownRef.current.contains(event.target as Node)) {
                setIsDropdownOpen(false);
            }
        };
        
        document.addEventListener('mousedown', handleClickOutside);
        return () => {
            document.removeEventListener('mousedown', handleClickOutside);
        };
    }, []);

    const handleVoteButtonClick = () => {
        setIsVotingModalOpen(true);
        setIsDropdownOpen(false);
        setIsVotingButtonAnimated(true);
        setIsThroneButtonAnimated(false);
        setIsEventsButtonAnimated(false);
    };

    const handleDecryptedThroneClick = () => {
        setIsDecryptedThroneOpen(true);
        setIsDropdownOpen(false);
        setIsThroneButtonAnimated(true);
        setIsVotingButtonAnimated(false);
        setIsEventsButtonAnimated(false);
    };

    const handleEventsButtonClick = () => {
        setIsDropdownOpen(!isDropdownOpen);
        if (!isDropdownOpen) {
            setIsEventsButtonAnimated(true);
        }
    };

    // ????? ???????? ??? ???????? ????????? ????
    const handleVotingModalClose = () => {
        setIsVotingModalOpen(false);
        setIsVotingButtonAnimated(false);
    };

    const handleDecryptedThroneClose = () => {
        setIsDecryptedThroneOpen(false);
        setIsThroneButtonAnimated(false);
    };

    // ????? ???????? ??? ???????? ??????????? ??????
    useEffect(() => {
        if (!isDropdownOpen) {
            setIsEventsButtonAnimated(false);
            setIsVotingButtonAnimated(false);
            setIsThroneButtonAnimated(false);
        }
    }, [isDropdownOpen]);

    // ?????????? ????????????? ????? ????????
    useEffect(() => {
        // ????????????? ????? ??? ?????? ??????????, ?????????? ?????????????, ?????? ?????????? ??? ?????? ?????????? ???????
        if (transactionCancelled || userRejectedTx || (transactionCompleted && showResult) || (result && result.includes("Insufficient balance"))) {
            if (glitchIntervalId) {
                clearInterval(glitchIntervalId);
                setGlitchIntervalId(null);
            }
            setIsGlitching(false);
            // ?????????? ???? ??????????????? ??????? ????
            setPendingVsComputerGame(false);
            pendingVsComputerGameRef.current = false;
        }
    }, [transactionCancelled, userRejectedTx, transactionCompleted, showResult, result, glitchIntervalId]);

    // ??????? ??? ??????? ?????????????? ??????
    const startPeriodicGlitch = () => {
        // ??????? ?????????? ???????? ???? ????
        if (glitchIntervalId) {
            clearInterval(glitchIntervalId);
        }

        // ????????? ????? ?????
        setIsGlitching(true);
        setTimeout(() => setIsGlitching(false), 600);

        // ????????????? ???????? ??? ?????????? ?????? ?????? 3 ???????
        const intervalId = setInterval(() => {
            setIsGlitching(true);
            setTimeout(() => setIsGlitching(false), 600);
        }, 3000);

        setGlitchIntervalId(intervalId);
    };

    // ??????? ??? ????????? ?????????????? ??????
    const stopPeriodicGlitch = () => {
        if (glitchIntervalId) {
            clearInterval(glitchIntervalId);
            setGlitchIntervalId(null);
        }
        setIsGlitching(false);
    };

    // ????? ?????? ????? (????? ?? DecryptedThrone)
    const glitchStyles = `
    .glitch-container {
      position: relative;
      overflow: visible;
      animation: 
        container-glitch 0.6s steps(20, end) forwards,
        block-distortion 0.6s steps(18, end) forwards,
        flash-effect 0.6s steps(12, end) forwards;
    }
    
    .glitch-container.active h2,
    .glitch-container.active p,
    .glitch-container.active span,
    .glitch-container.active div {
      animation: text-glitch 0.6s steps(15, end) forwards;
    }
    
    @keyframes text-glitch {
      0%, 20% {
        text-shadow: none;
        transform: translateX(0) skewX(0);
      }
      21% {
        text-shadow: 
          4px 0 0 rgba(255, 0, 255, 0.9), 
          -4px 0 0 rgba(0, 255, 255, 0.9),
          0 2px 0 rgba(255, 255, 0, 0.6),
          0 -2px 0 rgba(255, 0, 0, 0.6);
        transform: translateX(-5px) skewX(4deg);
      }
      24% {
        text-shadow: 
          -8px 0 0 rgba(255, 0, 0, 0.95), 
          8px 0 0 rgba(0, 255, 0, 0.95),
          0 5px 0 rgba(0, 255, 255, 0.7),
          0 -5px 0 rgba(255, 0, 255, 0.7);
        transform: translateX(6px) skewX(-5deg);
      }
      27% {
        text-shadow: 
          7px 0 0 rgba(255, 255, 0, 0.85), 
          -7px 0 0 rgba(255, 0, 255, 0.85),
          4px 4px 0 rgba(0, 255, 0, 0.5),
          -4px -4px 0 rgba(255, 0, 0, 0.5);
        transform: translateX(-4px) skewX(3.5deg);
      }
      30%, 45% {
        text-shadow: none;
        transform: translateX(0) skewX(0);
      }
      46% {
        text-shadow: 
          -4.5px 0 0 rgba(0, 255, 255, 0.9), 
          4.5px 0 0 rgba(255, 0, 0, 0.9),
          0 -2px 0 rgba(255, 255, 0, 0.8),
          0 2px 0 rgba(0, 255, 0, 0.8);
        transform: translateX(5.5px) skewX(-6deg);
      }
      49% {
        text-shadow: 
          10px 0 0 rgba(255, 0, 255, 0.8), 
          -10px 0 0 rgba(0, 255, 0, 0.8),
          5px 0 0 rgba(255, 255, 0, 0.6),
          -5px 0 0 rgba(0, 255, 255, 0.6);
        transform: translateX(-7px) skewX(7deg);
      }
      52% {
        text-shadow: 
          -8px 0 0 rgba(255, 255, 0, 0.85), 
          8px 0 0 rgba(0, 255, 255, 0.85),
          0 4px 0 rgba(255, 0, 0, 0.7),
          0 -4px 0 rgba(0, 255, 0, 0.7);
        transform: translateX(3.5px) skewX(-4deg);
      }
      55%, 70% {
        text-shadow: none;
        transform: translateX(0) skewX(0);
      }
      71% {
        text-shadow: 
          4.2px 0 0 rgba(255, 0, 0, 0.8), 
          -4.2px 0 0 rgba(0, 255, 0, 0.8),
          2px 2px 0 rgba(255, 0, 255, 0.6),
          -2px -2px 0 rgba(0, 255, 255, 0.6);
        transform: translateX(-3px) skewX(5deg);
      }
      74% {
        text-shadow: 
          -9px 0 0 rgba(255, 0, 255, 0.9), 
          9px 0 0 rgba(0, 255, 255, 0.9),
          0 5px 0 rgba(255, 255, 0, 0.7),
          0 -5px 0 rgba(255, 0, 0, 0.7);
        transform: translateX(4.5px) skewX(-5.5deg);
      }
      77%, 100% {
        text-shadow: none;
        transform: translateX(0) skewX(0);
      }
    }
    
    .glitch-container::before,
    .glitch-container::after {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      opacity: 0.4;
      z-index: 1000;
      border-radius: inherit;
    }
    
    .glitch-container::before {
      background: 
        linear-gradient(to right, transparent 0%, transparent 15%, rgba(255, 0, 255, 0.4) 20%, rgba(255, 0, 255, 0.4) 70%, transparent 75%, transparent 100%),
        linear-gradient(to right, transparent 0%, transparent 35%, rgba(255, 0, 255, 0.4) 40%, rgba(255, 0, 255, 0.4) 85%, transparent 90%, transparent 100%),
        linear-gradient(to right, transparent 0%, transparent 5%, rgba(255, 0, 255, 0.4) 10%, rgba(255, 0, 255, 0.4) 95%, transparent 100%),
        linear-gradient(to right, transparent 0%, transparent 60%, rgba(255, 0, 255, 0.3) 65%, rgba(255, 0, 255, 0.3) 85%, transparent 90%, transparent 100%),
        linear-gradient(to right, transparent 0%, transparent 25%, rgba(255, 0, 255, 0.3) 30%, rgba(255, 0, 255, 0.3) 55%, transparent 60%, transparent 100%);
      background-size: 
        100% 3px,
        100% 3px,
        100% 4px,
        100% 2px,
        100% 2px;
      background-position: 
        0 15%,
        0 35%,
        0 65%,
        0 82%,
        0 92%;
      background-repeat: no-repeat;
      animation: 
        container-glitch-line 0.6s steps(12, end) forwards,
        flash-overlay 0.6s steps(10, end) forwards;
    }
    
    .glitch-container::after {
      background: 
        linear-gradient(to right, transparent 0%, transparent 25%, rgba(0, 255, 255, 0.4) 30%, rgba(0, 255, 255, 0.4) 60%, transparent 65%, transparent 100%),
        linear-gradient(to right, transparent 0%, transparent 0%, rgba(0, 255, 255, 0.4) 5%, rgba(0, 255, 255, 0.4) 80%, transparent 85%, transparent 100%),
        linear-gradient(to right, transparent 0%, transparent 45%, rgba(0, 255, 255, 0.4) 50%, rgba(0, 255, 255, 0.4) 95%, transparent 100%),
        linear-gradient(to right, transparent 0%, transparent 70%, rgba(0, 255, 255, 0.3) 75%, rgba(0, 255, 255, 0.3) 90%, transparent 95%, transparent 100%),
        linear-gradient(to right, transparent 0%, transparent 10%, rgba(0, 255, 255, 0.3) 15%, rgba(0, 255, 255, 0.3) 40%, transparent 45%, transparent 100%);
      background-size: 
        100% 3px,
        100% 4px,
        100% 3px,
        100% 2px,
        100% 2px;
      background-position: 
        0 22%,
        0 48%,
        0 75%,
        0 8%,
        0 95%;
      background-repeat: no-repeat;
      animation: 
        container-glitch-line 0.6s steps(12, end) forwards,
        flash-overlay-alt 0.6s steps(8, end) forwards;
      animation-delay: 0.1s;
    }
    
    @keyframes container-glitch {
      0%, 20% {
        transform: translateX(0) translateY(0) skewX(0);
        filter: none;
      }
      21% {
        transform: translateX(-12px) translateY(3px) skewX(4deg);
        filter: hue-rotate(90deg) contrast(250%) brightness(180%) saturate(300%) invert(30%);
      }
      24% {
        transform: translateX(15px) translateY(-4px) skewX(-5deg);
        filter: hue-rotate(-120deg) contrast(300%) brightness(200%) saturate(350%) sepia(40%);
      }
      27% {
        transform: translateX(-8px) translateY(2.5px) skewX(3deg);
        filter: saturate(280%) contrast(270%) hue-rotate(60deg) invert(25%) blur(0.5px);
      }
      30%, 45% {
        transform: translateX(0) translateY(0) skewX(0);
        filter: none;
      }
      46% {
        transform: translateX(13px) translateY(-3.5px) skewX(-4.5deg);
        filter: hue-rotate(150deg) brightness(190%) contrast(280%) grayscale(20%);
      }
      49% {
        transform: translateX(-16px) translateY(4px) skewX(6deg);
        filter: contrast(320%) saturate(320%) hue-rotate(-90deg) invert(35%) sepia(30%);
      }
      52% {
        transform: translateX(10px) translateY(-2.5px) skewX(-3.5deg);
        filter: brightness(170%) hue-rotate(45deg) contrast(260%) blur(0.3px);
      }
      55%, 70% {
        transform: translateX(0) translateY(0) skewX(0);
        filter: none;
      }
      71% {
        transform: translateX(-11px) translateY(3.2px) skewX(4.5deg);
        filter: hue-rotate(-75deg) contrast(290%) brightness(160%) saturate(250%);
      }
      74% {
        transform: translateX(14px) translateY(-2.8px) skewX(-5.5deg);
        filter: saturate(300%) brightness(185%) contrast(310%) invert(20%);
      }
      77%, 100% {
        transform: translateX(0) translateY(0) skewX(0);
        filter: none;
      }
    }
    
    @keyframes block-distortion {
      0%, 20% {
        transform: scale(1) skewY(0) rotateZ(0);
        border-radius: 0.75rem;
      }
      21% {
        transform: scale(1.008, 0.992) skewY(1.5deg) rotateZ(0.5deg);
        border-radius: 0.5rem 1.2rem 0.4rem 0.9rem;
      }
      24% {
        transform: scale(0.985, 1.018) skewY(-2deg) rotateZ(-0.8deg);
        border-radius: 1.1rem 0.3rem 1rem 0.6rem;
      }
      27% {
        transform: scale(1.012, 0.988) skewY(1.2deg) rotateZ(0.3deg);
        border-radius: 0.6rem 0.8rem 1.3rem 0.2rem;
      }
      30%, 45% {
        transform: scale(1) skewY(0) rotateZ(0);
        border-radius: 0.75rem;
      }
      46% {
        transform: scale(0.992, 1.015) skewY(-1.8deg) rotateZ(-0.6deg);
        border-radius: 0.4rem 1.1rem 0.5rem 1.2rem;
      }
      49% {
        transform: scale(1.022, 0.978) skewY(2.5deg) rotateZ(1deg);
        border-radius: 1.3rem 0.2rem 0.9rem 0.7rem;
      }
      52% {
        transform: scale(0.988, 1.008) skewY(-1.4deg) rotateZ(-0.4deg);
        border-radius: 0.7rem 1rem 0.3rem 1.1rem;
      }
      55%, 70% {
        transform: scale(1) skewY(0) rotateZ(0);
        border-radius: 0.75rem;
      }
      71% {
        transform: scale(1.006, 0.994) skewY(1deg) rotateZ(0.7deg);
        border-radius: 0.8rem 0.5rem 1.2rem 0.4rem;
      }
      74% {
        transform: scale(0.994, 1.012) skewY(-1.6deg) rotateZ(-0.9deg);
        border-radius: 1rem 0.6rem 0.3rem 1.1rem;
      }
      77%, 100% {
        transform: scale(1) skewY(0) rotateZ(0);
        border-radius: 0.75rem;
      }
    }
    
    @keyframes flash-effect {
      0%, 20% {
        background-color: rgba(0, 0, 0, 0.6);
        border-color: rgba(147, 51, 234, 0.5);
        box-shadow: 0 0 0 0 transparent;
      }
      21% {
        background-color: rgba(255, 0, 255, 0.35);
        border-color: rgba(255, 0, 255, 1);
        box-shadow: 0 0 50px 15px rgba(255, 0, 255, 0.6), inset 0 0 20px rgba(255, 255, 255, 0.3);
      }
      22% {
        background-color: rgba(0, 255, 255, 0.32);
        border-color: rgba(0, 255, 255, 0.95);
        box-shadow: 0 0 45px 12px rgba(0, 255, 255, 0.55), inset 0 0 15px rgba(255, 255, 255, 0.25);
      }
      24% {
        background-color: rgba(255, 255, 0, 0.4);
        border-color: rgba(255, 255, 0, 1);
        box-shadow: 0 0 60px 18px rgba(255, 255, 0, 0.7), inset 0 0 25px rgba(255, 255, 255, 0.4);
      }
      27% {
        background-color: rgba(255, 0, 0, 0.28);
        border-color: rgba(255, 0, 0, 0.9);
        box-shadow: 0 0 35px 10px rgba(255, 0, 0, 0.5), inset 0 0 12px rgba(255, 255, 255, 0.2);
      }
      30%, 45% {
        background-color: rgba(0, 0, 0, 0.6);
        border-color: rgba(147, 51, 234, 0.5);
        box-shadow: 0 0 0 0 transparent;
      }
      46% {
        background-color: rgba(0, 255, 0, 0.12);
        border-color: rgba(0, 255, 0, 0.7);
        box-shadow: 0 0 18px 4px rgba(0, 255, 0, 0.25);
      }
      48% {
        background-color: rgba(255, 0, 255, 0.18);
        border-color: rgba(255, 0, 255, 0.9);
        box-shadow: 0 0 30px 8px rgba(255, 0, 255, 0.35);
      }
      52% {
        background-color: rgba(0, 255, 255, 0.14);
        border-color: rgba(0, 255, 255, 0.8);
        box-shadow: 0 0 22px 6px rgba(0, 255, 255, 0.3);
      }
      55%, 70% {
        background-color: rgba(0, 0, 0, 0.6);
        border-color: rgba(147, 51, 234, 0.5);
        box-shadow: 0 0 0 0 transparent;
      }
      71% {
        background-color: rgba(255, 255, 0, 0.16);
        border-color: rgba(255, 255, 0, 0.85);
        box-shadow: 0 0 28px 7px rgba(255, 255, 0, 0.32);
      }
      74% {
        background-color: rgba(255, 0, 0, 0.11);
        border-color: rgba(255, 0, 0, 0.65);
        box-shadow: 0 0 16px 4px rgba(255, 0, 0, 0.2);
      }
      77%, 100% {
        background-color: rgba(0, 0, 0, 0.6);
        border-color: rgba(147, 51, 234, 0.5);
        box-shadow: 0 0 0 0 transparent;
      }
    }
    
    @keyframes container-glitch-line {
      0%, 20% {
        transform: translateX(0) scaleX(1) skewX(0);
        opacity: 0;
      }
      21% {
        transform: translateX(-18px) scaleX(2) skewX(6deg);
        opacity: 0.9;
      }
      24% {
        transform: translateX(25px) scaleX(0.4) skewX(-8deg);
        opacity: 0.95;
      }
      27% {
        transform: translateX(-15px) scaleX(2.5) skewX(5deg);
        opacity: 0.8;
      }
      30%, 45% {
        transform: translateX(0) scaleX(1) skewX(0);
        opacity: 0;
      }
      46% {
        transform: translateX(22px) scaleX(0.3) skewX(-10deg);
        opacity: 0.85;
      }
      49% {
        transform: translateX(-28px) scaleX(3) skewX(12deg);
        opacity: 1;
      }
      52% {
        transform: translateX(16px) scaleX(0.5) skewX(-7deg);
        opacity: 0.75;
      }
      55%, 70% {
        transform: translateX(0) scaleX(1) skewX(0);
        opacity: 0;
      }
      71% {
        transform: translateX(-20px) scaleX(2.2) skewX(8deg);
        opacity: 0.7;
      }
      74% {
        transform: translateX(12px) scaleX(0.6) skewX(-6deg);
        opacity: 0.8;
      }
      77%, 100% {
        transform: translateX(0) scaleX(1) skewX(0);
        opacity: 0;
      }
    }
    
    @keyframes flash-overlay {
      0%, 20% {
        background: transparent;
      }
      21% {
        background: radial-gradient(circle at 30% 40%, rgba(255, 0, 255, 0.4) 0%, transparent 50%);
      }
      24% {
        background: radial-gradient(circle at 70% 20%, rgba(0, 255, 255, 0.3) 0%, transparent 60%);
      }
      27% {
        background: radial-gradient(circle at 50% 80%, rgba(255, 255, 0, 0.35) 0%, transparent 45%);
      }
      30%, 45% {
        background: transparent;
      }
      46% {
        background: radial-gradient(circle at 80% 60%, rgba(0, 255, 0, 0.3) 0%, transparent 55%);
      }
      49% {
        background: radial-gradient(circle at 20% 30%, rgba(255, 0, 255, 0.45) 0%, transparent 40%);
      }
      52% {
        background: radial-gradient(circle at 60% 70%, rgba(0, 255, 255, 0.38) 0%, transparent 50%);
      }
      55%, 70% {
        background: transparent;
      }
      71% {
        background: radial-gradient(circle at 40% 10%, rgba(255, 255, 0, 0.42) 0%, transparent 48%);
      }
      74% {
        background: radial-gradient(circle at 90% 50%, rgba(255, 0, 0, 0.32) 0%, transparent 52%);
      }
      77%, 100% {
        background: transparent;
      }
    }
    
    @keyframes flash-overlay-alt {
      0%, 20% {
        background: transparent;
      }
      22% {
        background: linear-gradient(45deg, rgba(255, 0, 255, 0.25) 0%, transparent 30%, rgba(0, 255, 255, 0.2) 70%, transparent 100%);
      }
      26% {
        background: linear-gradient(-45deg, rgba(255, 255, 0, 0.3) 0%, transparent 40%, rgba(255, 0, 0, 0.15) 60%, transparent 100%);
      }
      30%, 45% {
        background: transparent;
      }
      47% {
        background: linear-gradient(135deg, rgba(0, 255, 0, 0.28) 0%, transparent 35%, rgba(255, 0, 255, 0.22) 65%, transparent 100%);
      }
      51% {
        background: linear-gradient(-135deg, rgba(0, 255, 255, 0.35) 0%, transparent 45%, rgba(255, 255, 0, 0.18) 75%, transparent 100%);
      }
      55%, 70% {
        background: transparent;
      }
      72% {
        background: linear-gradient(90deg, rgba(255, 255, 0, 0.4) 0%, transparent 50%, rgba(255, 0, 0, 0.25) 100%);
      }
      77%, 100% {
        background: transparent;
      }
    }
    
    @keyframes book-pages {
      0% {
        transform: translateX(0);
      }
      25% {
        transform: translateX(-1px);
      }
      50% {
        transform: translateX(1px);
      }
      75% {
        transform: translateX(-0.5px);
      }
      100% {
        transform: translateX(0);
      }
    }
    
    @keyframes trophy-base {
      0% {
        transform: translateY(0);
      }
      50% {
        transform: translateY(-1px);
      }
      100% {
        transform: translateY(0);
      }
    }
    
    @keyframes trophy-shine {
      0% {
        filter: drop-shadow(0 0 0 rgba(255, 215, 0, 0));
      }
      50% {
        filter: drop-shadow(0 0 4px rgba(255, 215, 0, 0.6));
      }
      100% {
        filter: drop-shadow(0 0 0 rgba(255, 215, 0, 0));
      }
    }
    
    @keyframes trophy-glow {
      0% {
        fill: currentColor;
        filter: drop-shadow(0 0 0 rgba(255, 215, 0, 0));
      }
      50% {
        fill: rgba(255, 215, 0, 0.2);
        filter: drop-shadow(0 0 6px rgba(255, 215, 0, 0.8));
      }
      100% {
        fill: currentColor;
        filter: drop-shadow(0 0 0 rgba(255, 215, 0, 0));
      }
    }
    `;

    const toggleVotingResults = () => {
        setShowVotingResults(!showVotingResults);
    };
    
    const toggleDecryptedThroneResults = () => {
        setShowDecryptedThroneResults(!showDecryptedThroneResults);
    };

    const updatePlayerStats = async (result: 'win' | 'lose' | 'draw', isRanked: boolean = false) => {
        if (!publicKey) {
            return;
        }
        
        try {
            const walletAddress = publicKey.toString();
            
            // ????????? ?????????? ?????? ??? ??????????? ???
            if (isRanked) {
                let apiResult: 'win' | 'loss' | 'draw';
                if (result === 'win') {
                    apiResult = 'win';
                } else if (result === 'lose') {
                    apiResult = 'loss';
                } else {
                    apiResult = 'draw';
                }
                
                // ?????????? ????????? ???????? ??? ?????????? ?????????? ? ??????
                const response = await fetch('/api/ranked-game-complete', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        wallet_address: walletAddress,
                        result: apiResult
                    })
                });
                
                if (response.ok) {
                    const data = await response.json();
                    
                    // ????????? ????????? ????????? ?????? ??????????? ??????? ? ???????
                    if (data.daily_limit) {
                        setDailyLimit(data.daily_limit);
                    }
                } else if (response.status === 429) {
                    // ????? ?????????
                    console.log('Daily limit reached');
                    await fetchDailyLimit(); // ????????? ????????? ??????
                    throw new Error('Daily limit reached');
                } else {
                    console.error('Failed to complete rating game:', response.status);
                    await fetchDailyLimit(); // ? ?????? ?????? ?????????????? ?????????
                    throw new Error(`Failed to complete rating game: ${response.status}`);
                }
            }
        } catch (error) {
            console.error('Error updating player stats:', error);
            // ??? ????? ?????? ?????????????? ????????? ? ????????
            await fetchDailyLimit();
        }
    };

    const incrementDailyLimit = async () => {
        if (!publicKey) return;
        
        try {
            const response = await fetch('/api/daily-limit/increment', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    wallet_address: publicKey.toString()
                })
            });
            
            if (response.ok) {
                // ???????? ?????????? ?????? ? ??????? ?????? ?????????????? ??????????
                await fetchDailyLimit();
                console.log('Daily limit incremented successfully');
            } else if (response.status === 429) {
                // ????? ????????? - ???????? ?????????? ??????
                await fetchDailyLimit();
                console.log('Daily limit reached');
            } else {
                console.error('Failed to increment daily limit:', response.status);
                // ? ?????? ?????? ???? ???????? ?????????? ?????? ??? ?????????????
                await fetchDailyLimit();
            }
        } catch (error) {
            console.error('Error incrementing daily limit:', error);
            // ??? ?????? ???? ???????? ?????????? ??????
            await fetchDailyLimit();
        }
    };

    const getGameClient = () => {
        if (!wallet) throw new Error('Wallet not connected');

        const connection = new Connection('https://api.devnet.solana.com');
        
        const provider = new AnchorProvider(connection, wallet, {
            commitment: 'confirmed',
            preflightCommitment: 'confirmed'
        });
        return new GameClient(provider, PROGRAM_ID);
    };

    const initializeGame = async () => {
        if (!wallet || initializing) return null;

        try {
            setInitializing(true);
            const client = getGameClient();
            const newGameState = await client.initialize();
            setGameState(newGameState.publicKey);
            return newGameState;
        } catch (err) {
            console.error('Error initializing game:', err);
            return null;
        } finally {
            setInitializing(false);
        }
    };

    const determineWinner = (playerChoice: number, cpuChoice: number) => {
        if (playerChoice === cpuChoice) return 'draw';
        
        if (
            (playerChoice === 0 && cpuChoice === 2) || 
            (playerChoice === 1 && cpuChoice === 0) || 
            (playerChoice === 2 && cpuChoice === 1)    
        ) {
            return 'win';
        }
        
        return 'lose';
    };

    const executeTransaction = async (choiceValue: number) => {
        if (!wallet) {
            throw new Error("Wallet not connected");
        }
        
        if (choiceValue === null) {
            throw new Error("Choice must be selected");
        }
        
        try {
            if (gameState) {
                try {
                    const client = getGameClient();
                    const result = await client.submitMove(gameState, choiceValue);
                    return { publicKey: gameState, result };
                } catch (err: any) {
                    
                    if (err.message && (
                        err.message.includes("metadata not provided") || 
                        err.message.includes("Invalid arguments") || 
                        err.message.includes("metadata")
                    )) {
                        return { 
                            publicKey: gameState, 
                            result: { 
                                success: true, 
                                simulatedTx: "SIMULATED_TX_" + Date.now() 
                            } 
                        };
                    }
                    
                    throw err;
                }
            }
            
            try {
                const gameStateResult = await initializeGame();
                if (!gameStateResult) {
                    throw new Error("Failed to initialize game state");
                }
                
                const client = getGameClient();
                const result = await client.submitMove(gameStateResult.publicKey, choiceValue);
                return { publicKey: gameStateResult.publicKey, result };
            } catch (err: any) {
                
                if (err.message && (
                    err.message.includes("metadata not provided") || 
                    err.message.includes("Invalid arguments") || 
                    err.message.includes("metadata")
                )) {
                    const gameStateResult = gameState || (await initializeGame());
                    if (!gameStateResult) {
                        throw new Error("Failed to initialize game state");
                    }
                    
                    return { 
                        publicKey: gameStateResult.publicKey, 
                        result: { 
                            success: true, 
                            simulatedTx: "SIMULATED_TX_" + Date.now() 
                        } 
                    };
                }
                
                throw err;
            }
        } catch (error) {
            throw error;
        }
    };
    
    // ??????????????? ??????? ??? ??????? ???? ? ???? ?????????? choice
    const handleSubmitWithChoice = (isRankedGame: boolean, choiceValue: number) => {
        
        if (!connected || !wallet || choiceValue === null || loading) {
            return;
        }
        
        // ????????? choice ? ref ??? ????????????? ? handleSubmit
        pendingChoiceRef.current = choiceValue;
        
        // ????, ???? React ??????? ????????? choice, ????? ???????? handleSubmit
        setTimeout(() => {
            handleSubmit(isRankedGame);
        }, 500); // ??????????? ???????? ??? ???????? ?????????? ?????????
    };
    
    const handleSubmit = async (isRankedGame: boolean = false) => {
        // ?????????? choice ?? ref ???? ?? ??????????, ????? ?? state
        const currentChoice = pendingChoiceRef.current !== null ? pendingChoiceRef.current : choice;
        
        if (!connected || !wallet || currentChoice === null || loading) {
            return;
        }
        
        // ????????? choice ? state ???? ???????????? ???????? ?? ref
        if (pendingChoiceRef.current !== null) {
            setChoice(currentChoice);
        }
        
        // ?????????? ref ????? ?????????????
        pendingChoiceRef.current = null;

        // ????????? ????? ??? ??????????? ???
        if (isRankedGame && dailyLimit.limit_reached) {
            setError("Daily limit reached! You can play up to 5 rating games per day.");
            return;
        }

        // ????????? ????????????? ????? ??????
        startPeriodicGlitch();

        setGameMode(isRankedGame ? 'ranked' : 'practice');
        setLoading(true);
        setError(null);
        setTransactionCancelled(false);
        setUserRejectedTx(false);
        
        const messages = [
            "Sending move to blockchain...",
            "Waiting for transaction confirmation...",
            "Performing confidential computation...",
            "Retrieving game result..."
        ];
        
        let currentMessageIndex = 0;
        setResult(messages[currentMessageIndex]);
        
        const messageTimer = setInterval(() => {
            currentMessageIndex = (currentMessageIndex + 1) % messages.length;
            setResult(messages[currentMessageIndex]);
        }, 3000);
        
        try {
            const txResult = await executeTransaction(currentChoice);
            
            clearInterval(messageTimer);
            
            if (txResult) {
                if (txResult.result && typeof txResult.result === 'object') {
                    if ('tx' in txResult.result && typeof txResult.result.tx === 'string') {
                        setTxId(txResult.result.tx);
                    } else if ('simulatedTx' in txResult.result) {
                        setTxId(txResult.result.simulatedTx);
                    }
                } else if (txResult.publicKey && txResult.result) {
                    const gameResult = txResult.result;
                    if (gameResult && typeof gameResult === 'object') {
                        const txFromResult = (gameResult as any).tx;
                        if (typeof txFromResult === 'string') {
                            setTxId(txFromResult);
                        }
                    }
                }
            }
            
            if (txResult?.result && 'confidentialResult' in txResult.result) {
                const confidentialResult = txResult.result.confidentialResult as {
                    computerMove: number;
                    result: number;
                    resultHash: string;
                };
                
                const { computerMove, result } = confidentialResult;
                
                setComputerChoice(computerMove);
                
                let gameResultValue: 'win' | 'lose' | 'draw';
                if (result === 0) {
                    gameResultValue = 'win';
                } else if (result === 1) {
                    gameResultValue = 'lose';
                } else {
                    gameResultValue = 'draw';
                }
                
                setGameResult(gameResultValue);
                
                // ??? ???????? ??? updatePlayerStats ??? ???????? ????????? ??????
                await updatePlayerStats(gameResultValue, isRankedGame);
                
                // ??????? ????????? ????? ????? ?????????? ????
                if (myLobbyId) {
                    setMyLobbyId(null);
                    setWaitingForOpponent(false);
                    localStorage.removeItem('myLobbyId');
                    localStorage.removeItem('waitingForOpponent');
                }
                
                setShowResult(true);
                setResult("Game completed!");
                setTransactionCompleted(true);
            } else {
                const cpuChoice = Math.floor(Math.random() * 3);
                setComputerChoice(cpuChoice);
                const outcome = determineWinner(currentChoice, cpuChoice);
                setGameResult(outcome as 'win' | 'lose' | 'draw');
                
                // ??? ???????? ??? updatePlayerStats ??? ???????? ????????? ??????
                await updatePlayerStats(outcome as 'win' | 'lose' | 'draw', isRankedGame);
                
                // ??????? ????????? ????? ????? ?????????? ????
                if (myLobbyId) {
                    setMyLobbyId(null);
                    setWaitingForOpponent(false);
                    localStorage.removeItem('myLobbyId');
                    localStorage.removeItem('waitingForOpponent');
                }
                
                setResult("Game completed!");
                setShowResult(true);
                setTransactionCompleted(true);
            }
        } catch (error: any) {
            clearInterval(messageTimer);
            stopPeriodicGlitch();
            
            if (error.message && (
                error.message.includes("rejected") ||
                error.message.includes("cancelled") ||
                error.message.includes("denied") ||
                error.message.includes("User rejected") ||
                error.message.includes("decline") ||
                error.message.includes("cancel")
            )) {
                setTransactionCancelled(true);
                setUserRejectedTx(true);
                setGameMode('practice');
                setChoice(null);
                setMyLobbyId(null);
                setWaitingForOpponent(false);
                setShowLobbyMenu(false);
                setResult("Transaction was cancelled by the user");
                return;
            } else if (error.message && (
                error.message.includes("insufficient") ||
                error.message.includes("not enough") ||
                error.message.includes("balance") ||
                error.message.includes("funds") ||
                error.message.includes("SOL") ||
                error.message.includes("lamports") ||
                error.message.includes("fee") ||
                error.message.includes("cost") ||
                error.message.includes("payment") ||
                error.message.includes("account") ||
                error.message.includes("debit an account") ||
                error.message.includes("no record of a prior credit") ||
                error.message.toLowerCase().includes("insufficient") ||
                error.message.toLowerCase().includes("balance") ||
                error.message.toLowerCase().includes("funds")
            )) {
                stopPeriodicGlitch();
                setTransactionCancelled(false);
                setUserRejectedTx(false);
                setLoading(false);
                setGameMode('practice');
                setChoice(null);
                setMyLobbyId(null);
                setWaitingForOpponent(false);
                setShowLobbyMenu(false);
                setResult("Insufficient balance. Please get some SOL from the faucet.");
                return;
            } else {
                // ?????????? ????? ?????????? ??? ?????? ???????
                setTransactionCancelled(false);
                setUserRejectedTx(false);
                setGameMode('practice');
                setChoice(null);
                setMyLobbyId(null);
                setWaitingForOpponent(false);
                setShowLobbyMenu(false);
                setResult("Processing move...");

                await new Promise(resolve => setTimeout(resolve, 2000));

                try {
                    const cpuChoice = Math.floor(Math.random() * 3);
                    setComputerChoice(cpuChoice);
                    const outcome = determineWinner(currentChoice, cpuChoice) as 'win' | 'lose' | 'draw';
                    setGameResult(outcome);

                    // ??? ???????? ??? updatePlayerStats ??? ???????? ????????? ??????
                    await updatePlayerStats(outcome, isRankedGame);

                    // ??????? ????????? ????? ????? ?????????? ????
                    if (myLobbyId) {
                        setMyLobbyId(null);
                        setWaitingForOpponent(false);
                        localStorage.removeItem('myLobbyId');
                        localStorage.removeItem('waitingForOpponent');
                    }

                    setShowResult(true);
                    setResult("Game completed!");
                    setTransactionCompleted(true);
                } catch (innerError) {
                    setError("An error occurred while processing the move. Please try again.");
                    setLoading(false);
                }
            }
        } finally {
            clearInterval(messageTimer);
            setLoading(false);
        }
    };

    const handleTryAgain = () => {
        // ????????????? ????????????? ?????
        stopPeriodicGlitch();

        setTransactionCancelled(false);
        setUserRejectedTx(false);
        setResult(null);
        setError(null);
        setGameMode('practice');
        setChoice(null);
        setMyLobbyId(null);
        setWaitingForOpponent(false);
        setShowLobbyMenu(false);
        setLoading(false);
    };

    // ??????? ??? ???????? ???? ? ????? ? ???????????
    const submitLobbyChoice = async (lobbyId: string, selectedChoice: number) => {
        if (!publicKey) return;

        let messageTimer: NodeJS.Timeout | null = null;

        try {
            setLoading(true);

            // ????????? ??????? ?????????, ??? ? ??????? ????
            const messages = [
                "Sending move to blockchain...",
                "Waiting for transaction confirmation...",
                "Performing confidential computation...",
                "Retrieving game result..."
            ];

            let currentMessageIndex = 0;
            setResult(messages[currentMessageIndex]);

            messageTimer = setInterval(() => {
                currentMessageIndex = (currentMessageIndex + 1) % messages.length;
                setResult(messages[currentMessageIndex]);
            }, 3000);

            // ??????? ?????????? ?????????? ??? ? Play vs Computer
            let txResult;
            try {
                txResult = await executeTransaction(selectedChoice);
            } catch (txError: any) {
                if (messageTimer) {
                    clearInterval(messageTimer);
                }

                // ???? ?????????? ???????? ????????????? ? ?? ? ????? - ??????? ?? ?????
                if (txError.message && (
                    txError.message.includes("User rejected") ||
                    txError.message.includes("cancelled") ||
                    txError.message.includes("rejected")
                ) && myLobbyId) {
                    // ??????????, ???????? ?? ????? ?????????? ?????
                    const isCreator = lobbyData && lobbyData.wallet_address === publicKey?.toString();

                    try {
                        if (isCreator) {
                            // ????????? ????? - ??????? ?????
                            await fetch(`/api/lobbies/${myLobbyId}`, { method: 'DELETE' });
                        } else {
                            // ???????????????? ???????????? - ??????? ?? ?????
                            await fetch(`/api/lobbies/${myLobbyId}/leave`, {
                                method: 'POST',
                                headers: {
                                    'Content-Type': 'application/json',
                                },
                                body: JSON.stringify({
                                    wallet_address: publicKey?.toString(),
                                }),
                            });
                        }

                        // ??????? ????????? ?????
                        setMyLobbyId(null);
                        setWaitingForOpponent(false);
                        setShowLobbyMenu(false);
                        setLobbyData(null);
                        setChoice(null);
                        localStorage.removeItem('myLobbyId');
                        localStorage.removeItem('waitingForOpponent');
                        setResult(null);
                    } catch (leaveError) {
                        // ??????? ????????? ????????? ???? ??? ?????? API
                        setMyLobbyId(null);
                        setWaitingForOpponent(false);
                        setShowLobbyMenu(false);
                        setLobbyData(null);
                        setChoice(null);
                        localStorage.removeItem('myLobbyId');
                        localStorage.removeItem('waitingForOpponent');
                        setResult(null);
                    }
                    throw new Error("Transaction cancelled.");
                }

                // ????????? ?? ?????? ?????????? ???????
                const errorMessage = txError.message || String(txError);
                if (errorMessage && (
                    errorMessage.includes("insufficient") ||
                    errorMessage.includes("not enough") ||
                    errorMessage.includes("balance") ||
                    errorMessage.includes("funds") ||
                    errorMessage.includes("SOL") ||
                    errorMessage.includes("lamports") ||
                    errorMessage.includes("fee") ||
                    errorMessage.includes("cost") ||
                    errorMessage.includes("payment") ||
                    errorMessage.includes("account") ||
                    errorMessage.includes("debit an account") ||
                    errorMessage.includes("no record of a prior credit") ||
                    errorMessage.toLowerCase().includes("insufficient") ||
                    errorMessage.toLowerCase().includes("balance") ||
                    errorMessage.toLowerCase().includes("funds")
                )) {
                    if (messageTimer) {
                        clearInterval(messageTimer);
                    }

                    // ??????????, ???????? ?? ????? ?????????? ?????
                    const isCreator = lobbyData && lobbyData.wallet_address === publicKey?.toString();

                    if (isCreator) {
                        // ????????? ????? - ??????? ?????
                        try {
                            await fetch(`/api/lobbies/${lobbyId}`, { method: 'DELETE' });
                        } catch (deleteError) {
                            // ?????????? ?????? ????????
                        }
                    } else {
                        // ???????????????? ???????????? - ??????? ?? ?????
                        try {
                            await fetch(`/api/lobbies/${lobbyId}/leave`, {
                                method: 'POST',
                                headers: {
                                    'Content-Type': 'application/json',
                                },
                                body: JSON.stringify({
                                    wallet_address: publicKey?.toString(),
                                }),
                            });
                        } catch (leaveError) {
                            // ?????????? ?????? ??????
                        }
                    }

                    // ??????? ????????? ?????
                    setMyLobbyId(null);
                    setWaitingForOpponent(false);
                    setShowLobbyMenu(false);
                    setLobbyData(null);
                    setChoice(null);
                    localStorage.removeItem('myLobbyId');
                    localStorage.removeItem('waitingForOpponent');
                    setResult(null);

                    stopPeriodicGlitch();
                    throw new Error("Insufficient balance. Please get some SOL from the faucet.");
                }

                throw txError;
            }

            // ???????? transaction ID ?? executeTransaction ??? ?? ?????????
            let currentTxId = txId;
            if (txResult && txResult.result && typeof txResult.result === 'object') {
                if ('tx' in txResult.result && typeof txResult.result.tx === 'string') {
                    currentTxId = txResult.result.tx;
                    setTxId(txResult.result.tx); // ????????? ?????????
                } else if ('simulatedTx' in txResult.result) {
                    currentTxId = txResult.result.simulatedTx;
                    setTxId(txResult.result.simulatedTx); // ????????? ?????????
                }
            }

            // ?????????, ??? ? ??? ???? transaction ID
            if (!currentTxId) {
                setResult('Error: No transaction ID');
                return;
            }

            // ????? ????????? ??? ? ????? ? transaction ID

            const response = await fetch(`/api/lobbies/${lobbyId}/submit-choice`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    wallet_address: publicKey.toString(),
                    choice: selectedChoice,
                    tx_id: currentTxId
                })
            });
            
            const data = await response.json();
            
            if (!response.ok) {
                throw new Error(data.error || 'Failed to submit choice');
            }
            
            // ???????? ??????????? ?????? ?????
            const lobbyResponse = await fetch(`/api/lobbies/my-lobby/${publicKey.toString()}`);
            const lobbyInfo = await lobbyResponse.json();

            if (lobbyInfo.lobby) {
                setLobbyData(lobbyInfo.lobby);
            }
            
            if (data.game_ready) {
                // ????????????? polling ??? ??? ???? ?????????
                if (pollingIntervalRef.current) {
                    clearInterval(pollingIntervalRef.current);
                    pollingIntervalRef.current = null;
                }
                
                // ??? ?????? ??????? ???? - ?????????? ?????????
                setComputerChoice(data.creator_choice === selectedChoice ? data.joiner_choice : data.creator_choice);
                setGameResult(data.result);
                setIsPvPGame(true); // ????????????? ???? PvP ????
                
                // ????????? ??????????
                await updatePlayerStats(data.result, true);
                
                // ?? ??????? lobbyData ????? - ?? ????? ??? ??????????? ??????????
                setMyLobbyId(null);
                setWaitingForOpponent(false);
                setShowLobbyMenu(false);
                // setLobbyData(null); - ????????? ??? ??????????? ??????????
                localStorage.removeItem('myLobbyId');
                localStorage.removeItem('waitingForOpponent');
                
                setShowResult(true);
                setResult("Multiplayer game completed!");
                setTransactionCompleted(true);
            } else {
                // ?????????? ????? ???? ?????? ????? ???????? ????
                setShowLobbyMenu(true);
                setWaitingForOpponent(true);
                setResult(null); // ??????? ?????????, ????? ?? ???????????? "Processing your move..."
                localStorage.setItem('waitingForOpponent', 'true');

                // ?????? ???????? ????????????? ???????? ?????????? ????? ???????? ????
                startPollGameResult(lobbyId);
            }
        } catch (error: any) {
            if (messageTimer) {
                clearInterval(messageTimer);
            }
            stopPeriodicGlitch();
            setTransactionCancelled(false);
            setUserRejectedTx(false);

            const errorMessage = error.message || 'Failed to submit choice';

            // ??????????? ????????? ?????? "Lobby not found"
            if (errorMessage.includes('Lobby not found')) {
                // ??????? ????????? ????? ??? ?????? "Lobby not found"
                setMyLobbyId(null);
                setWaitingForOpponent(false);
                setShowLobbyMenu(false);
                setLobbyData(null);
                setChoice(null);
                localStorage.removeItem('myLobbyId');
                localStorage.removeItem('waitingForOpponent');
            }

            setResult(errorMessage);
            setShowLobbyMenu(false);
        } finally {
            if (messageTimer) {
                clearInterval(messageTimer);
            }
            setLoading(false);
        }
    };

    // ????????????? ???????? ?????????? ????
    const startPollGameResult = (lobbyId: string) => {
        
        // ????????????? ?????????? polling ???? ????
        if (pollingIntervalRef.current) {
            clearInterval(pollingIntervalRef.current);
            pollingIntervalRef.current = null;
        }
        
        pollingIntervalRef.current = setInterval(async () => {
            if (!publicKey) {
                clearInterval(pollingIntervalRef.current!);
                pollingIntervalRef.current = null;
                return;
            }
            
            try {
                const response = await fetch(`/api/lobbies/my-lobby/${publicKey.toString()}`);
                const data = await response.json();
                
                if (data.lobby) {
                    // ????????? ?????? ?????
                    setLobbyData(data.lobby);
                    
                    // ????????? ???? ???? ?????????
                    if (data.lobby.status === 'completed') {
                        clearInterval(pollingIntervalRef.current!);
                        pollingIntervalRef.current = null;
                        
                        // ???? ????????? - ?????????? ????????? ??? ? ??????? ????
                        const isCreator = data.lobby.is_creator;
                        const myChoice = isCreator ? data.lobby.creator_choice : data.lobby.joiner_choice;
                        const opponentChoice = isCreator ? data.lobby.joiner_choice : data.lobby.creator_choice;
                        
                        // ????????? ? ????? ?????? ???????? ??????
                        let myResult = 'draw';
                        if ((myChoice === 0 && opponentChoice === 2) ||
                            (myChoice === 1 && opponentChoice === 0) ||
                            (myChoice === 2 && opponentChoice === 1)) {
                            myResult = 'win';
                        } else if (myChoice !== opponentChoice) {
                            myResult = 'lose';
                        }
                        
                        
                        // ????????????? ????????? ????
                        setChoice(myChoice);
                        setComputerChoice(opponentChoice);
                        setGameResult(myResult as 'win' | 'lose' | 'draw');
                        setIsPvPGame(true); // ????????????? ???? PvP ????
                        
                        // ????????? ??????????
                        await updatePlayerStats(myResult as 'win' | 'lose' | 'draw', true);
                        
                        // ?? ??????? lobbyData ????? - ?? ????? ??? ??????????? ??????????
                        setMyLobbyId(null);
                        setWaitingForOpponent(false);
                        setShowLobbyMenu(false);
                        // setLobbyData(null); - ????????? ??? ??????????? ??????????
                        localStorage.removeItem('myLobbyId');
                        localStorage.removeItem('waitingForOpponent');

                        // ????????? lobbyData ? ?????? ??????? ?? ??
                        try {
                            const response = await fetch(`/api/lobbies/my-lobby/${publicKey.toString()}`);
                            const updatedData = await response.json();
                            if (updatedData.lobby) {
                                setLobbyData(updatedData.lobby);
                            }
                        } catch (error) {
                            // Error updating lobby data after game completion
                        }

                        // ?????????? ?????????
                        setShowResult(true);
                        setResult("Multiplayer game completed!");
                        setTransactionCompleted(true);
                        return;
                    }
                }
                
                if (!data.lobby) {
                    clearInterval(pollingIntervalRef.current!);
                    pollingIntervalRef.current = null;
                }
                
            } catch (error: any) {
                // ??????????? ????????? ?????? "Lobby not found" ??? polling
                if (error.message && error.message.includes('Lobby not found')) {
                    clearInterval(pollingIntervalRef.current!);
                    pollingIntervalRef.current = null;

                    // ??????? ????????? ????? ??? ?????? "Lobby not found"
                    setMyLobbyId(null);
                    setWaitingForOpponent(false);
                    setShowLobbyMenu(false);
                    setLobbyData(null);
                    setChoice(null);
                    localStorage.removeItem('myLobbyId');
                    localStorage.removeItem('waitingForOpponent');
                }
                // Error polling game result
            }
        }, 1000); // ????????? ?????? ??????? ??? ??????? ???????
        
        // ????????????? ???????? ????? 5 ?????
        setTimeout(() => {
            if (pollingIntervalRef.current) {
                clearInterval(pollingIntervalRef.current);
                pollingIntervalRef.current = null;
            }
        }, 5 * 60 * 1000);
    };

    const shouldShowGameResult = () => {
        if (userRejectedTx) {
            return false;
        }
        return transactionCompleted && showResult;
    };

    const shouldShowCancelMessage = () => {
        return userRejectedTx || transactionCancelled;
    };

    // ??????? ??? ????????? ?????? ????
    const getMoveText = (move: number | null) => {
        if (move === null) return 'Not selected';
        switch (move) {
            case 0: return 'Rock';
            case 1: return 'Paper';
            case 2: return 'Scissors';
            default: return 'Unknown';
        }
    };

    // ????????? ????? ????
    const renderLobbyMenu = () => {
        const currentWallet = publicKey?.toString();
        const isCreator = lobbyData.wallet_address === currentWallet;
        const isJoiner = lobbyData.joiner_wallet === currentWallet;

        const currentPlayerChoice = isCreator ? lobbyData.creator_choice : lobbyData.joiner_choice;
        const opponentChoice = isCreator ? lobbyData.joiner_choice : lobbyData.creator_choice;
        const opponentWallet = isCreator ? lobbyData.joiner_wallet : lobbyData.wallet_address;
        const hasOpponent = lobbyData.status === 'in_progress';

        // ?????????? ??? ?????????
        let opponentDisplayName = "Waiting for Opponent";
        if (hasOpponent) {
            if (isCreator && lobbyData.joiner_discord_username) {
                opponentDisplayName = lobbyData.joiner_discord_username;
            } else if (isCreator && lobbyData.joiner_wallet) {
                opponentDisplayName = `${lobbyData.joiner_wallet.slice(0, 4)}...${lobbyData.joiner_wallet.slice(-4)}`;
            } else if (isJoiner && lobbyData.creator_discord_username) {
                opponentDisplayName = lobbyData.creator_discord_username;
            } else if (isJoiner && lobbyData.wallet_address) {
                opponentDisplayName = `${lobbyData.wallet_address.slice(0, 4)}...${lobbyData.wallet_address.slice(-4)}`;
            } else {
                opponentDisplayName = "Opponent";
            }
        }

        return (
            <div className="p-6 rounded-lg border border-purple-800/50 bg-purple-900/20 text-center animate-border-glow">
                <h3 className="text-2xl font-bold mb-4 text-purple-300">
                    Multiplayer Lobby
                </h3>

                <div className="grid grid-cols-2 gap-4 mb-4">
                    {/* Your Move */}
                    <div className="px-2 py-0.5 rounded-lg border border-purple-800/30 bg-purple-950/40">
                        <p className="text-purple-400 font-semibold mb-0.5">Your Move</p>
                        <div className="flex flex-col items-center">
                            {currentPlayerChoice !== null ? (
                                <>
                                    <img 
                                        src={`/Icons/${getMoveText(currentPlayerChoice).toLowerCase()}.png`} 
                                        alt={getMoveText(currentPlayerChoice)} 
                                        className="w-[5.7rem] h-[5.7rem]" 
                                    />
                                    <p className="text-lg text-purple-200 -mt-3">{getMoveText(currentPlayerChoice)}</p>
                                </>
                            ) : (
                                <>
                                    <div className="w-[5.7rem] h-[5.7rem] flex items-center justify-center">
                                        <span className="text-gray-400 text-sm">Not selected</span>
                                    </div>
                                    <p className="text-lg text-gray-400 -mt-3">Not selected</p>
                                </>
                            )}
                        </div>
                    </div>
                    
                    {/* Opponent's Move */}
                    <div className="px-2 py-0.5 rounded-lg border border-purple-800/30 bg-purple-950/40">
                        <p className="text-purple-400 font-semibold mb-0.5">
                            {opponentDisplayName}
                        </p>
                        <div className="flex flex-col items-center">
                            {hasOpponent ? (
                                opponentChoice !== null ? (
                                    <>
                                        <div className="w-[5.7rem] h-[5.7rem] flex items-center justify-center">
                                            <span className="text-green-400 text-sm">Move made</span>
                                        </div>
                                        <p className="text-lg text-green-400 -mt-3">Move made</p>
                                    </>
                                ) : (
                                    <>
                                        <div className="w-[5.7rem] h-[5.7rem] rounded-lg flex items-center justify-center">
                                            <div className="w-8 h-8 border-2 border-purple-400 border-t-transparent rounded-full animate-spin"></div>
                                        </div>
                                        <p className="text-lg text-yellow-400 -mt-3">Choosing move</p>
                                    </>
                                )
                            ) : (
                                <>
                                    <div className="w-[5.7rem] h-[5.7rem] rounded-lg flex items-center justify-center">
                                        <div className="w-8 h-8 border-2 border-gray-400 border-t-transparent rounded-full animate-spin"></div>
                                    </div>
                                    <p className="text-lg text-gray-400 -mt-3">Waiting</p>
                                </>
                            )}
                        </div>
                    </div>
                </div>

                {/* Status Message */}
                <div className="p-3 rounded-lg text-sm mb-6 bg-blue-900/30 text-blue-300">
                    {!hasOpponent
                        ? 'Waiting for an opponent to join your lobby...'
                        : opponentChoice === null
                            ? 'Waiting for opponent to make their move...'
                            : 'Both moves submitted! Processing result...'}
                </div>

                {/* Close/Leave Lobby Button */}
                <button
                    onClick={async () => {
                        if (isCreator) {
                            // ????????? ????? - ??????? ?????
                            try {
                                const response = await fetch(`/api/lobbies/${myLobbyId}`, {
                                    method: 'DELETE',
                                });

                                if (response.ok) {
                                    setMyLobbyId(null);
                                    setWaitingForOpponent(false);
                                    setShowLobbyMenu(false);
                                    setLobbyData(null);
                                    setChoice(null);
                                    localStorage.removeItem('myLobbyId');
                                    localStorage.removeItem('waitingForOpponent');
                                    setResult(null);
                                }
                            } catch (error) {
                                // Error closing lobby
                            }
                        } else {
                            // ???????????????? ???????????? - ??????? ????? API
                            try {
                                const response = await fetch(`/api/lobbies/${myLobbyId}/leave`, {
                                    method: 'POST',
                                    headers: {
                                        'Content-Type': 'application/json',
                                    },
                                    body: JSON.stringify({
                                        wallet_address: publicKey?.toString(),
                                    }),
                                });

                                if (response.ok) {
                                    setMyLobbyId(null);
                                    setWaitingForOpponent(false);
                                    setShowLobbyMenu(false);
                                    setLobbyData(null);
                                    setChoice(null);
                                    localStorage.removeItem('myLobbyId');
                                    localStorage.removeItem('waitingForOpponent');
                                    setResult(null);
                                } else {
                                    // Failed to leave lobby - still clear local state
                                    setMyLobbyId(null);
                                    setWaitingForOpponent(false);
                                    setShowLobbyMenu(false);
                                    setLobbyData(null);
                                    setChoice(null);
                                    localStorage.removeItem('myLobbyId');
                                    localStorage.removeItem('waitingForOpponent');
                                    setResult(null);
                                }
                            } catch (error) {
                                // Error leaving lobby - still clear local state
                                setMyLobbyId(null);
                                setWaitingForOpponent(false);
                                setShowLobbyMenu(false);
                                setLobbyData(null);
                                setChoice(null);
                                localStorage.removeItem('myLobbyId');
                                localStorage.removeItem('waitingForOpponent');
                                setResult(null);
                            }
                        }
                    }}
                    className="py-3 px-6 bg-red-700 hover:bg-red-600 text-white rounded-lg transition-all duration-300 shadow-red-500/30"
                >
                    {isCreator ? 'Close Lobby' : 'Leave Lobby'}
                </button>
            </div>
        );
    };

    const resetGame = () => {
        // ????????????? ????????????? ?????
        stopPeriodicGlitch();
        
        setChoice(null);
        setShowResult(false);
        setGameResult(null);
        setComputerChoice(null);
        setResult(null);
        setTxId(null);
        setTransactionCancelled(false);
        setUserRejectedTx(false);
        setTransactionCompleted(false);
        setGameState(null);
        setGameMode('practice');
        setError(null);
        setIsPvPGame(false);
        setLobbyData(null);
        setTimeUntilReset('');
        // ??????? polling ????????
        if (pollingIntervalRef.current) {
            clearInterval(pollingIntervalRef.current);
            pollingIntervalRef.current = null;
        }
    };

    const GameResultDisplay = () => {
        const playerMove = getMoveText(choice);
        const computerMove = getMoveText(computerChoice);
        
        let resultText = '';
        let resultClass = '';
        
        if (gameResult === 'win') {
            resultText = 'You won!';
            resultClass = 'text-green-400';
        } else if (gameResult === 'lose') {
            resultText = 'You lost!';
            resultClass = 'text-red-400';
        } else {
            resultText = 'It\'s a draw!';
            resultClass = 'text-yellow-400';
        }
        
        // ??? PvP ??? ???????? ?????????? ? ?????????
        let opponentDisplayName = "Computer's Move";
        let myTxId = txId;
        let opponentTxId = null;
        
        if (isPvPGame && lobbyData && publicKey) {
            const currentWallet = publicKey.toString();
            const isCreator = lobbyData.wallet_address === currentWallet;
            const isJoiner = lobbyData.joiner_wallet === currentWallet;

            // ?????????? ??? ?????????
            if (isCreator && lobbyData.joiner_discord_username) {
                opponentDisplayName = lobbyData.joiner_discord_username;
            } else if (isCreator && lobbyData.joiner_wallet) {
                opponentDisplayName = `${lobbyData.joiner_wallet.slice(0, 4)}...${lobbyData.joiner_wallet.slice(-4)}`;
            } else if (isJoiner && lobbyData.creator_discord_username) {
                opponentDisplayName = lobbyData.creator_discord_username;
            } else if (isJoiner && lobbyData.wallet_address) {
                opponentDisplayName = `${lobbyData.wallet_address.slice(0, 4)}...${lobbyData.wallet_address.slice(-4)}`;
            } else {
                opponentDisplayName = "Opponent";
            }

            // ?????????? transaction ID - ??? ??? ???????? ????????????, ????????? ??? ???????
            if (isCreator) {
                myTxId = lobbyData.creator_tx_id;
                opponentTxId = lobbyData.joiner_tx_id;
            } else if (isJoiner) {
                myTxId = lobbyData.joiner_tx_id;
                opponentTxId = lobbyData.creator_tx_id;
            }
        }
        
        return (
            <div className="p-6 rounded-lg border border-purple-800/50 bg-purple-900/20 text-center animate-border-glow">
                <h3 className={`text-2xl font-bold mb-4 ${resultClass}`}>
                    {resultText}
                </h3>
                
                <div className="grid grid-cols-2 gap-4 mb-4">
                    <div className="px-2 py-0.5 rounded-lg border border-purple-800/30 bg-purple-950/40">
                        <p className="text-purple-400 font-semibold mb-0.5">Your Move</p>
                        <div className="flex flex-col items-center">
                            <img 
                                src={`/Icons/${playerMove.toLowerCase()}.png`} 
                                alt={playerMove} 
                                className="w-[5.7rem] h-[5.7rem]" 
                            />
                            <p className="text-lg text-purple-200 -mt-3">{playerMove}</p>
                        </div>
                    </div>
                    
                    <div className="px-2 py-0.5 rounded-lg border border-purple-800/30 bg-purple-950/40">
                        <p className="text-purple-400 font-semibold mb-0.5">{opponentDisplayName}</p>
                        <div className="flex flex-col items-center">
                            <img 
                                src={`/Icons/${computerMove.toLowerCase()}.png`} 
                                alt={computerMove} 
                                className="w-[5.7rem] h-[5.7rem]" 
                            />
                            <p className="text-lg text-purple-200 -mt-3">{computerMove}</p>
                        </div>
                    </div>
                </div>
                
                <div className={`p-3 rounded-lg text-sm mb-6 ${
                    isPvPGame
                        ? 'bg-purple-900/30 text-purple-300'
                        : gameMode === 'ranked' 
                        ? 'bg-green-900/30 text-green-300' 
                        : 'bg-blue-900/30 text-blue-300'
                }`}>
                    {isPvPGame 
                        ? 'Multiplayer Rating game completed! Stats updated and sent to blockchain!'
                        : gameMode === 'ranked' 
                        ? 'Rating game completed! Stats updated and sent to blockchain!' 
                        : 'Practice game completed! Play rating mode to save stats and climb the leaderboard!'
                    }
                </div>
                
                {/* Transaction Links */}
                {myTxId && !myTxId.includes('fallback_tx') && !myTxId.includes('SIMULATED_TX_') && (
                    <div className="p-3 rounded-lg text-sm mb-6 bg-blue-900/30 text-blue-300">
                        <p>View transaction in explorer:</p>
                        <a
                            href={`https://explorer.solana.com/tx/${myTxId}?cluster=devnet`}
                            target="_blank"
                            rel="noopener noreferrer"
                            className="text-blue-400 hover:text-blue-300 underline"
                        >
                            Solana Explorer
                        </a>
                    </div>
                )}
                
                <button
                    onClick={resetGame}
                    className="py-3 px-6 bg-purple-700 hover:bg-purple-600 text-white rounded-lg transition-all duration-300 shadow-purple-500/30"
                >
                    Play Again
                </button>
            </div>
        );
    };

    const handleRockSelection = async () => {
        const selectedChoice = 0;
        setChoice(selectedChoice);
        
        if (result && (result.includes('Please select') || result.includes('Error'))) {
            setResult(null);
        }
        
        // ?????????, ????????? ?? ???????????? ? ?????
        if (myLobbyId && publicKey) {
            await submitLobbyChoice(myLobbyId, selectedChoice);
            return;
        }
        
        if (pendingVsComputerGameRef.current && connected && !dailyLimit.limit_reached) {
            pendingVsComputerGameRef.current = false;
            setPendingVsComputerGame(false);
            // ???????? ????????? ???????? ???????? (??? ??????????????? setTimeout)
            handleSubmitWithChoice(true, selectedChoice);
        }
    };

    const handlePaperSelection = async () => {
        const selectedChoice = 1;
        setChoice(selectedChoice);
        
        if (result && (result.includes('Please select') || result.includes('Error'))) {
            setResult(null);
        }
        
        // ?????????, ????????? ?? ???????????? ? ?????
        if (myLobbyId && publicKey) {
            await submitLobbyChoice(myLobbyId, selectedChoice);
            return;
        }
        
        if (pendingVsComputerGameRef.current && connected && !dailyLimit.limit_reached) {
            pendingVsComputerGameRef.current = false;
            setPendingVsComputerGame(false);
            // ???????? ????????? ???????? ???????? (??? ??????????????? setTimeout)
            handleSubmitWithChoice(true, selectedChoice);
        }
    };

    const handleScissorsSelection = async () => {
        const selectedChoice = 2;
        setChoice(selectedChoice);
        
        if (result && (result.includes('Please select') || result.includes('Error'))) {
            setResult(null);
        }
        
        // ?????????, ????????? ?? ???????????? ? ?????
        if (myLobbyId && publicKey) {
            await submitLobbyChoice(myLobbyId, selectedChoice);
            return;
        }
        
        if (pendingVsComputerGameRef.current && connected && !dailyLimit.limit_reached) {
            pendingVsComputerGameRef.current = false;
            setPendingVsComputerGame(false);
            // ???????? ????????? ???????? ???????? (??? ??????????????? setTimeout)
            handleSubmitWithChoice(true, selectedChoice);
        }
    };

    const renderErrorMessage = () => {
        if (!transactionCancelled) return null;
        
        return (
            <div className="mt-6 p-4 rounded-lg text-center bg-red-900/30 text-red-300 border border-red-700/50 animate-border-glow">
                <p className="mb-2 font-semibold">Transaction was cancelled or rejected</p>
                <p className="text-sm opacity-80 mb-3">You rejected the transaction in your wallet. No transaction was sent.</p>
                <button
                    onClick={handleTryAgain}
                    className="mt-3 py-2 px-4 bg-red-800/50 hover:bg-red-700/50 text-red-200 rounded-lg transition-all duration-300 text-sm"
                >
                    Try Again
                </button>
            </div>
        );
    };

    const renderGameContent = () => (
        <div className={`relative w-full overflow-hidden border border-purple-800/50 shadow-lg bg-black/60 backdrop-blur-sm rounded-xl mb-10 animate-border-glow ${isGlitching ? 'glitch-container active' : ''}`}>
            <div className="relative z-10 border-b border-purple-800/30 p-6">
                <h2 className="text-center text-3xl gradient-text">
                    Arcane Hands
                </h2>
                <p className="text-center text-purple-300 text-base mt-2">
                    Powered by Arcium's Confidential Computing on Solana
                </p>
            </div>
            
            <div className="relative z-10 p-8">
                {showLobbyMenu && lobbyData ? (
                    renderLobbyMenu()
                ) : shouldShowGameResult() && !userRejectedTx ? (
                    <GameResultDisplay />
                ) : (
                    <>
                        <p className="text-center text-lg text-purple-200 mb-6">Choose your move:</p>
                        
                        <div className="grid grid-cols-1 md:grid-cols-3 gap-6 mb-8">
                            <button
                                type="button"
                                onClick={handleRockSelection}
                                className={`cursor-pointer p-1 rounded-xl border-2 ${
                                    (loading || transactionCancelled || showLobbyMenu) && choice !== 0
                                        ? 'opacity-50 cursor-not-allowed border-purple-800/50'
                                        : choice === 0
                                        ? 'border-purple-500 bg-purple-700'
                                        : 'border-purple-800/50 hover:border-purple-500 hover:bg-purple-900/20'
                                } transition-all duration-300 ${!(loading || transactionCancelled || showLobbyMenu) ? 'transform hover:scale-105' : ''}`}
                                disabled={loading || transactionCancelled || showLobbyMenu}
                            >
                                <div className="flex flex-col items-center justify-center">
                                    <img src="/Icons/rock.png" alt="Rock" className="w-[5.7rem] h-[5.7rem]" />
                                    <div className="text-base text-purple-300 font-bold -mt-1">Rock</div>
                                </div>
                            </button>
                            
                            <button
                                type="button"
                                onClick={handlePaperSelection}
                                className={`cursor-pointer p-1 rounded-xl border-2 ${
                                    (loading || transactionCancelled || showLobbyMenu) && choice !== 1
                                        ? 'opacity-50 cursor-not-allowed border-purple-800/50'
                                        : choice === 1
                                        ? 'border-purple-500 bg-purple-700'
                                        : 'border-purple-800/50 hover:border-purple-500 hover:bg-purple-900/20'
                                } transition-all duration-300 ${!(loading || transactionCancelled || showLobbyMenu) ? 'transform hover:scale-105' : ''}`}
                                disabled={loading || transactionCancelled || showLobbyMenu}
                            >
                                <div className="flex flex-col items-center justify-center">
                                    <img src="/Icons/paper.png" alt="Paper" className="w-[5.7rem] h-[5.7rem]" />
                                    <div className="text-base text-purple-300 font-bold -mt-1">Paper</div>
                                </div>
                            </button>
                            
                            <button
                                type="button"
                                onClick={handleScissorsSelection}
                                className={`cursor-pointer p-1 rounded-xl border-2 ${
                                    (loading || transactionCancelled || showLobbyMenu) && choice !== 2
                                        ? 'opacity-50 cursor-not-allowed border-purple-800/50'
                                        : choice === 2
                                        ? 'border-purple-500 bg-purple-700'
                                        : 'border-purple-800/50 hover:border-purple-500 hover:bg-purple-900/20'
                                } transition-all duration-300 ${!(loading || transactionCancelled || showLobbyMenu) ? 'transform hover:scale-105' : ''}`}
                                disabled={loading || transactionCancelled || showLobbyMenu}
                            >
                                <div className="flex flex-col items-center justify-center">
                                    <img src="/Icons/scissors.png" alt="Scissors" className="w-[5.7rem] h-[5.7rem]" />
                                    <div className="text-base text-purple-300 font-bold -mt-1">Scissors</div>
                                </div>
                            </button>
                        </div>

                        <div className="mt-6 space-y-4">
                            {/* Buttons in one row */}
                            <div className="grid grid-cols-2 gap-4">
                                {/* Practice Mode Button */}
                                <button 
                                    type="button"
                                    onClick={() => {
                                        setIsPracticeButtonAnimated(true);
                                        setTimeout(() => setIsPracticeButtonAnimated(false), 300);
                                        handleSubmit(false);
                                    }}
                                    onMouseEnter={() => setIsPracticeButtonAnimated(true)}
                                    onMouseLeave={() => setIsPracticeButtonAnimated(false)}
                                    disabled={choice === null || loading || transactionCancelled || !connected || showLobbyMenu || gameMode === 'ranked' || myLobbyId !== null}
                                    className={`py-4 px-4 text-base rounded-xl font-bold flex items-center justify-center gap-2
                                        ${choice === null || loading || transactionCancelled || !connected || showLobbyMenu || gameMode === 'ranked' || myLobbyId !== null ? 'opacity-50 cursor-not-allowed bg-purple-800/50' : 'bg-purple-500/70 hover:bg-purple-600/80 text-white shadow-purple-500/30'} transition-all duration-300`}
                                >
                                    <AnimatedBookIcon 
                                        isAnimated={isPracticeButtonAnimated} 
                                        className={`w-4 h-4 ${loading ? 'opacity-0' : ''}`} 
                                    />
                                    {loading && gameMode === 'practice' ? 'Processing...' : 'Practice Game'}
                                </button>

                                {/* Rating Mode Button */}
                                <button 
                                    type="button"
                                    onClick={() => {
                                        setIsRankedButtonAnimated(true);
                                        setTimeout(() => setIsRankedButtonAnimated(false), 300);
                                        setIsLobbyModalOpen(true);
                                    }}
                                    onMouseEnter={() => setIsRankedButtonAnimated(true)}
                                    onMouseLeave={() => setIsRankedButtonAnimated(false)}
                                    disabled={loading || transactionCancelled || !connected || showLobbyMenu || choice === null || myLobbyId !== null}
                                    className={`py-4 px-4 text-base rounded-xl font-bold flex items-center justify-center gap-2
                                        ${loading || transactionCancelled || !connected || showLobbyMenu || choice === null || myLobbyId !== null ? 'opacity-50 cursor-not-allowed bg-purple-900/50' : 'bg-purple-800 hover:bg-purple-600 text-white shadow-purple-500/30'} transition-all duration-300 relative`}
                                >
                                    <AnimatedTrophyIconGame 
                                        isAnimated={isRankedButtonAnimated} 
                                        className={`w-4 h-4 ${loading ? 'opacity-0' : ''}`} 
                                    />
                                    {loading && gameMode === 'ranked' ? 'Processing...' : 'Rating Game (Multiplayer)'}
                                    {connected && (
                                        <span className="absolute -top-2 -right-2 bg-yellow-500 text-black text-xs px-2 py-1 rounded-full font-bold">
                                            {dailyLimit.attempts_remaining}/5
                                        </span>
                                    )}
                                </button>
                            </div>
                            
                            {!connected && (
                                <div className="text-yellow-400 text-center mt-3 font-medium">
                                    Please connect your wallet
                                </div>
                            )}

                            {dailyLimit.limit_reached && connected && (
                                <div className="text-orange-400 text-center mt-3 font-medium text-sm">
                                    <div className="flex flex-col items-center gap-2">
                                        <div>Daily limit reached! Practice mode available anytime.</div>
                                        <div className="flex items-center gap-2 bg-orange-900/30 px-3 py-2 rounded-lg border border-orange-700/50">
                                            <ClockIcon className="w-4 h-4 text-orange-400" />
                                            <span className="font-mono text-orange-200">
                                                Reset in: {timeUntilReset}
                                            </span>
                                        </div>
                                    </div>
                                </div>
                            )}

                            {connected && !dailyLimit.limit_reached && (
                                <div className="text-purple-300 text-center mt-2 text-sm">
                                    <span className="font-semibold">Practice:</span> Play without limits, no stats recorded<br/>
                                    <span className="font-semibold">Rating:</span> Counts towards leaderboard ({dailyLimit.attempts_remaining} attempts left today)
                                </div>
                            )}
                        </div>
                    </>
                )}
                
                {renderErrorMessage()}
                
                {result && !shouldShowGameResult() && !shouldShowCancelMessage() && (
                    <div className={`mt-6 p-4 rounded-lg text-center ${
                        result.includes('Error') || result.includes('Please select') || result.includes('Insufficient') || result.includes('Transaction cancelled') || result.includes('Lobby not found')
                        ? 'bg-red-900/30 text-red-300'
                        : result.includes('Initializing')
                          ? 'bg-blue-900/30 text-blue-300'
                          : 'bg-green-900/30 text-green-300'
                    }`}>
                        {result}
                    </div>
                )}

                {/* Cancel/Leave Lobby Button - show only when waiting for opponent to join */}
                {result && result.includes('Please select your move') && myLobbyId && !showLobbyMenu && (
                    <div className="mt-4 flex justify-center">
                        <button
                            onClick={async () => {
                                // ??????????, ???????? ?? ????? ?????????? ?????
                                const isCreator = lobbyData && lobbyData.wallet_address === publicKey?.toString();

                                try {
                                    if (isCreator) {
                                        // ????????? ????? - ??????? ?????
                                        const response = await fetch(`/api/lobbies/${myLobbyId}`, {
                                            method: 'DELETE',
                                        });

                                        if (response.ok) {
                                            setMyLobbyId(null);
                                            setWaitingForOpponent(false);
                                            setShowLobbyMenu(false);
                                            setLobbyData(null);
                                            setChoice(null);
                                            localStorage.removeItem('myLobbyId');
                                            localStorage.removeItem('waitingForOpponent');
                                            setResult(null);
                                        }
                                    } else {
                                        // ???????????????? ???????????? - ??????? ?? ?????
                                        const response = await fetch(`/api/lobbies/${myLobbyId}/leave`, {
                                            method: 'POST',
                                            headers: {
                                                'Content-Type': 'application/json',
                                            },
                                            body: JSON.stringify({
                                                wallet_address: publicKey?.toString(),
                                            }),
                                        });

                                        if (response.ok) {
                                            setMyLobbyId(null);
                                            setWaitingForOpponent(false);
                                            setShowLobbyMenu(false);
                                            setLobbyData(null);
                                            setChoice(null);
                                            localStorage.removeItem('myLobbyId');
                                            localStorage.removeItem('waitingForOpponent');
                                            setResult(null);
                                        } else {
                                            // Failed to leave lobby - still clear local state
                                            setMyLobbyId(null);
                                            setWaitingForOpponent(false);
                                            setShowLobbyMenu(false);
                                            setLobbyData(null);
                                            setChoice(null);
                                            localStorage.removeItem('myLobbyId');
                                            localStorage.removeItem('waitingForOpponent');
                                            setResult(null);
                                        }
                                    }
                                } catch (error) {
                                    // Error leaving/canceling lobby - still clear local state
                                    setMyLobbyId(null);
                                    setWaitingForOpponent(false);
                                    setShowLobbyMenu(false);
                                    setLobbyData(null);
                                    setChoice(null);
                                    localStorage.removeItem('myLobbyId');
                                    localStorage.removeItem('waitingForOpponent');
                                    setResult(null);
                                }
                            }}
                            className="py-2 px-4 bg-red-700 hover:bg-red-600 text-white rounded-lg transition-all duration-300 shadow-red-500/30 text-sm"
                        >
                            {lobbyData && lobbyData.wallet_address === publicKey?.toString() ? 'Cancel' : 'Leave Lobby'}
                        </button>
                    </div>
                )}

                {error && (
                    <div className="mt-6 p-4 rounded-lg text-center bg-red-900/30 text-red-300 border border-red-700/50">
                        {error}
                    </div>
                )}
            </div>
            
            <div className="relative z-10 flex flex-col text-sm text-purple-300 border-t border-purple-800/30 p-6">
                <div className="text-sm text-purple-200 mb-3">
                    <p className="text-center"><strong>How it works:</strong> Arcium enables confidential computing on Solana, allowing both players to submit encrypted moves that remain private until the game is resolved.</p>
                </div>
                <div className="flex justify-center items-center gap-3 text-sm">
                    <div className="flex items-center gap-1">
                        <LockIcon className="w-4 h-4 text-purple-400" />
                        <span>Private Moves</span>
                    </div>
                    <span className="mx-1 text-purple-700"></span>
                    <div className="flex items-center gap-1">
                        <ShieldIcon className="w-4 h-4 text-purple-400" />
                        <span>Secure Processing</span>
                    </div>
                    <span className="mx-1 text-purple-700"></span>
                    <div className="flex items-center gap-1">
                        <span className="w-4 h-4 text-purple-400 flex items-center justify-center">
                            <span className="text-base">=</span>
                        </span>
                        <span>Fair Play</span>
                    </div>
                </div>
            </div>
        </div>
    );

    const renderHowContent = () => (
        <div className="w-full overflow-hidden border border-purple-800/50 shadow-lg bg-black/60 backdrop-blur-sm rounded-xl animate-border-glow">
            <div className="p-8">
                <h2 className="text-2xl md:text-3xl font-bold gradient-text mb-6">How Confidential Computing Works</h2>
                
                <div className="bg-black/30 p-6 rounded-xl mb-8">
                    <p className="text-purple-200">
                        Traditional on-chain games face a fundamental challenge: all data on the blockchain is 
                        public. In a game like Rock Paper Scissors, if one player's move is visible, the other player 
                        could simply wait to see it before making their own move, making the game unfair.
                    </p>
                </div>
                
                <div className="space-y-8">
                    <div className="relative">
                        <h3 className="text-xl md:text-2xl font-bold text-purple-300 mb-4 flex items-center gap-3">
                            <div className="bg-purple-600 p-2 rounded-xl">
                            <LockIcon className="w-6 h-6 text-white" />
                            </div>
                            Arcium's Solution
                        </h3>
                        
                        <p className="text-purple-200 mb-4">Arcium enables confidential computing on Solana through these steps:</p>
                        
                        <ol className="space-y-4 list-disc list-inside text-purple-200">
                            <li className="p-3 bg-purple-950/30 rounded-xl">
                                <strong className="text-purple-300">Confidential Move Submission:</strong> Players submit encrypted moves (Rock, Paper, or Scissors)
                        </li>
                            <li className="p-3 bg-purple-950/30 rounded-xl">
                                <strong className="text-purple-300">Off-Chain Computation:</strong> The Arcium network processes game logic confidentially
                        </li>
                            <li className="p-3 bg-purple-950/30 rounded-xl">
                                <strong className="text-purple-300">Fair Resolution:</strong> The result is computed without revealing either player's move
                        </li>
                            <li className="p-3 bg-purple-950/30 rounded-xl">
                                <strong className="text-purple-300">On-Chain Result:</strong> Only the final outcome is published to the blockchain
                        </li>
                    </ol>
                    </div>
                    
                    <div className="relative">
                        <h3 className="text-xl md:text-2xl font-bold text-purple-300 mb-4 flex items-center gap-3">
                            <div className="bg-purple-600 p-2 rounded-xl">
                                <ShieldIcon className="w-6 h-6 text-white" />
                            </div>
                            Security Benefits
                        </h3>
                        
                        <ul className="space-y-4 list-disc list-inside text-purple-200">
                            <li className="p-3 bg-purple-950/30 rounded-xl">
                                <strong className="text-purple-300">Move Privacy:</strong> Neither player can see the other's move until both are committed
                        </li>
                            <li className="p-3 bg-purple-950/30 rounded-xl">
                                <strong className="text-purple-300">Fair Play:</strong> Game logic runs in a trusted execution environment
                        </li>
                            <li className="p-3 bg-purple-950/30 rounded-xl">
                                <strong className="text-purple-300">Transparent Resolution:</strong> While moves are private, the outcome is publicly verifiable
                        </li>
                            <li className="p-3 bg-purple-950/30 rounded-xl">
                                <strong className="text-purple-300">No Front-Running:</strong> Players cannot manipulate the game by observing on-chain data
                        </li>
                        </ul>
                    </div>
                </div>
            </div>
        </div>
    );

    return (
        <div className="min-h-screen flex flex-col relative">
            <style dangerouslySetInnerHTML={{ __html: glitchStyles }} />
            <div className="absolute inset-0 z-0">
                <LetterGlitch
                    glitchSpeed={80}
                    centerVignette={true}
                    outerVignette={false}
                    smooth={true}
                    fullscreen={true}
                    performanceMode={true}
                    glitchColors={["#2b3945", "#6161dc", "#9061dc"]}
                />
            </div>
            
            <header className="relative z-50 w-full h-16">
                <div className="absolute top-2 right-2 flex items-center gap-1 sm:gap-1 md:gap-2">
                    <div className="relative" ref={dropdownRef}>
                        <button 
                            onClick={handleEventsButtonClick}
                            onMouseEnter={() => setIsEventsButtonAnimated(true)}
                            onMouseLeave={() => !isDropdownOpen && setIsEventsButtonAnimated(false)}
                            className="!bg-purple-700 hover:!bg-purple-600 !text-white !px-3 sm:!px-4 md:!px-5 !py-2 sm:!py-2 md:!py-2.5 !rounded-lg !shadow-purple-500/30 !text-xs sm:!text-sm md:!text-base flex items-center gap-1 relative"
                        >
                            {(!showVotingResults || !showDecryptedThroneResults) && (
                                <div className="absolute top-1.5 right-1.5 w-2 h-2 bg-red-500 rounded-full animate-red-dot-pulse"></div>
                            )}
                            <AnimatedTrophyIconMain isAnimated={isEventsButtonAnimated} className="w-4 h-4" />
                            <span className="mr-1">Events</span>
                            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={`transition-transform duration-200 ${isDropdownOpen ? 'rotate-180' : ''}`}>
                                <polyline points="6 9 12 15 18 9"></polyline>
                            </svg>
                        </button>
                        
                        {isDropdownOpen && (
                            <div className="absolute left-0 mt-2 w-56 bg-black/80 backdrop-blur-sm rounded-xl shadow-xl z-10 border border-purple-800/50 animate-border-glow overflow-hidden animate-slideDown opacity-0" style={{ animationFillMode: 'forwards' }}>
                                <div className="p-1.5 space-y-1.5">
                                    <button
                                        onClick={handleVoteButtonClick}
                                        onMouseEnter={() => setIsVotingButtonAnimated(true)}
                                        onMouseLeave={() => !isVotingModalOpen && setIsVotingButtonAnimated(false)}
                                        className="relative !bg-purple-700 hover:!bg-purple-600 !text-white !px-4 !py-2 !rounded-lg !shadow-purple-500/30 !text-sm flex items-center gap-1 w-full animate-fadeIn opacity-0"
                                        style={{ animationDelay: '0.02s', animationFillMode: 'forwards' }}
                                    >
                                        {!showVotingResults && (
                                            <div className="absolute top-1.5 right-1.5 w-2 h-2 bg-red-500 rounded-full animate-red-dot-pulse"></div>
                                        )}
                                        <AnimatedClockIcon isAnimated={isVotingButtonAnimated} className="w-4 h-4 mr-1.5" />
                                        <span>Weekly Vote</span>
                                    </button>
                                    <button
                                        onClick={handleDecryptedThroneClick}
                                        onMouseEnter={() => setIsThroneButtonAnimated(true)}
                                        onMouseLeave={() => !isDecryptedThroneOpen && setIsThroneButtonAnimated(false)}
                                        className="relative !bg-purple-700 hover:!bg-purple-600 !text-white !px-4 !py-2 !rounded-lg !shadow-purple-500/30 !text-sm flex items-center gap-1 w-full animate-fadeIn opacity-0"
                                        style={{ animationDelay: '0.04s', animationFillMode: 'forwards' }}
                                    >
                                        {!showDecryptedThroneResults && (
                                            <div className="absolute top-1.5 right-1.5 w-2 h-2 bg-red-500 rounded-full animate-red-dot-pulse"></div>
                                        )}
                                        <AnimatedLockIcon isAnimated={isThroneButtonAnimated} className="w-4 h-4 mr-1.5" />
                                        <span>Decrypted Throne</span>
                                    </button>
                                </div>
                            </div>
                        )}
                    </div>
                    
                    <UserMenuDropdown />
                    <FaucetButton />
                    <WalletMultiButton className="!bg-purple-700 hover:!bg-purple-600 !text-white !px-3 sm:!px-4 md:!px-5 !py-1.5 sm:!py-2 md:!py-2.5 !rounded-lg !shadow-purple-500/30 !text-xs sm:!text-sm md:!text-base" />
                </div>
            </header>
            
            <main className="flex-1 relative z-20">
                <div className="container mx-auto max-w-4xl px-4">
                    <div className="relative w-full h-40 overflow-hidden border border-purple-800/50 shadow-lg bg-black/60 backdrop-blur-sm rounded-xl mb-6 animate-border-glow">
                        <div className="text-center mb-4 mt-5 backdrop-blur-sm p-4 rounded-lg bg-black/40">
                            <h1 className="text-4xl md:text-5xl font-bold gradient-text">
                                Arcane Hands
                            </h1>
                            <p className="text-center text-purple-300 mt-3 max-w-2xl mx-auto text-lg">
                                A demonstration of confidential computing on Solana using Arcium
                            </p>
                        </div>
                    </div>
                    
                    <div className="flex flex-col sm:flex-row justify-center sm:space-x-8 space-y-4 sm:space-y-0 mb-6 backdrop-blur-sm py-2 px-4 rounded-lg bg-black/40 mx-auto">
                        <div className="flex items-center gap-2 bg-purple-900/80 px-6 py-3 rounded-full">
                            <LockIcon className="w-5 h-5 text-purple-300" />
                            <span className="text-purple-200 font-medium">Private Moves</span>
                        </div>
                        
                        <div className="flex items-center gap-2 bg-purple-900/80 px-6 py-3 rounded-full">
                            <ShieldIcon className="w-5 h-5 text-purple-300" />
                            <span className="text-purple-200 font-medium">Secure Computation</span>
                        </div>
                        
                        <div className="flex items-center gap-2 bg-purple-900/80 px-6 py-3 rounded-full">
                            <ChipIcon className="w-5 h-5 text-purple-300" />
                            <span className="text-purple-200 font-medium">On-Chain Results</span>
                        </div>
                    </div>
                    
                    <div className="flex flex-col gap-8 max-w-4xl mx-auto mt-8">
                        {renderGameContent()}
                        {renderHowContent()}
                    </div>
                </div>
            </main>
            
            <footer className="py-8 border-t border-purple-900/30 backdrop-blur-sm relative z-20 top-16">
                <div className="container mx-auto px-4">
                    <div className="flex flex-col items-center">
                        <p className="text-center text-purple-300 text-sm">
                            This demo illustrates Arcium's confidential computing capabilities on Solana.
                        </p>
                        <p className="text-center text-purple-300 text-sm mt-2">
                            Made by <a href="https://x.com/rodionadov" target="_blank" rel="noopener noreferrer" className="text-purple-500 hover:text-purple-400 transition-colors">@adovrn</a>
                        </p>
                        <div className="mt-4 flex items-center gap-2">
                            <span className="text-purple-300 text-xs">Secure  Private  Verifiable</span>
                        </div>
                    </div>
                </div>
            </footer>
            
            <VotingModal 
                isOpen={isVotingModalOpen} 
                onClose={handleVotingModalClose}
                showResults={showVotingResults}
            />
            
            <DecryptedThrone
                isOpen={isDecryptedThroneOpen}
                onClose={handleDecryptedThroneClose}
                showResults={showDecryptedThroneResults}
            />
            
            <LobbyModal
                isOpen={isLobbyModalOpen}
                onClose={() => setIsLobbyModalOpen(false)}
                onPlayVsComputer={() => {
                    
                    // ????????? ???? ???? ???????? ?????
                    if (myLobbyId) {
                        setResult('Please close your lobby first to play vs computer');
                        return;
                    }
                    
                    setIsLobbyModalOpen(false);
                    if (!dailyLimit.limit_reached && connected) {
                        if (choice !== null) {
                            // ???? ??? ??? ?????? - ????? ????????? ????
                            handleSubmit(true);
                        } else {
                            // ???? ??? ?? ?????? - ????????????? ???? ??? ???????????
                            setPendingVsComputerGame(true);
                            pendingVsComputerGameRef.current = true;
                        }
                    }
                }}
                onCreateLobby={async (lobbyId) => {
                    setChoice(null); // ?????????? ????? ???????? ??? ???????? ?????
                    setShowLobbyMenu(false); // ????????? ????? ???????? ????? ???????? ?????
                    setMyLobbyId(lobbyId);
                    localStorage.setItem('myLobbyId', lobbyId);
                    setIsLobbyModalOpen(false);
                    setResult('Please select your move (Rock, Paper, or Scissors) and wait for opponent');

                    // ???????? ?????? ?????????? ?????
                    if (publicKey) {
                        try {
                            const response = await fetch(`/api/lobbies/my-lobby/${publicKey.toString()}`);
                            const data = await response.json();

                            if (data.lobby) {
                                setLobbyData(data.lobby);
                            }
                        } catch (error) {
                            // Error fetching lobby data after creation
                        }
                    }
                }}
                onJoinLobby={async () => {
                    setChoice(null); // ?????????? ????? ???????? ??? ??????????? ? ?????
                    setIsLobbyModalOpen(false);
                    setResult('Please select your move (Rock, Paper, or Scissors)');

                    // ?????????? ??? ????? ???? ?? ???????????? ????? Join
                    setShowLobbyMenu(false);
                    
                    // ????????? ?????? ????? ????? ?????????????
                    if (publicKey) {
                        try {
                            const response = await fetch(`/api/lobbies/my-lobby/${publicKey.toString()}`);
                            const data = await response.json();
                            
                            if (data.lobby) {
                                setMyLobbyId(data.lobby.id);
                                setLobbyData(data.lobby);
                                localStorage.setItem('myLobbyId', data.lobby.id);
                                
                                // ?? ?????????? ????? ???? ????? Join - ???????????? ?????? ??????? ??????? ????????
                            }
                        } catch (error) {
                            // Error fetching lobby data after join
                        }
                    }
                }}
                onCloseLobby={() => {
                    setMyLobbyId(null);
                    setWaitingForOpponent(false);
                    setShowLobbyMenu(false);
                    setLobbyData(null);
                    setChoice(null);
                    localStorage.removeItem('myLobbyId');
                    localStorage.removeItem('waitingForOpponent');
                    setResult(null);
                }}
                myLobbyId={myLobbyId}
                dailyLimit={dailyLimit}
            />
        </div>
    );
}; 